<!DOCTYPE html>
<html>
  <title>Nangaku Building</title>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /*changing asthetics (MERGER)*/
      body {
        font-family: "Raleway", sans-serif;
        font-weight: normal;
        font-style: normal;
        overflow: hidden;
      }
      /*asthetic*/
      .sidenavd{
        height: 65px;
        width: 1%;
        top: 50px;
        left: 30px;
        background-color: rgb(175, 28, 64);
        position: absolute;
      }
      /* directions */
      .sidenavc{
        height: 6%;
        width: 21%;
        top: 50px;
        left: 50px;
        background-color: #ffffff;
        position: absolute;
        padding-top: 10px;
        padding-left: 10px;
      }
      /* title*/
      .sidenavb {
        height: 6%;
        width: 100%;
        left: -3px;
        position: absolute;
        top: 57.5%;
        background-color: #ffffff;
        overflow-x: hidden;
        padding-top: 7px;
        border: solid rgb(175, 28, 64);

      }
      /* list of events*/
      .sidenav {
        height: 35%;
        width: 100%;
        left:0;
        position: absolute;
        bottom: 0;
        background-color: #ffffff;
        overflow-x: hidden;
        padding-top: 0px;
      }

      /* title at top */
      g {
        font-size: 36px;
        padding: 0px 3px 0px 7px;
        color: rgb(175, 28, 64);
      }

      directions {
        font-size: 18px;
        color: rgb(175, 28, 64);
      }

      info {
        font-size: 18px;
        color: rgb(175, 28, 64);
      }

      /*asthetic rectangle

      .rectangle {
        position: absolute;
        left: 10px;
        height: 10px;
        width: 571px;
        align: left;
        background-color: rgb(175, 28, 64);
      }
      */

      button {
        position: absolute;
        height: 0px;
        width: 0px;
      }

      /* list of events */
      .sidenav a {
        /* space between (top, right side, bottom, left side )*/
        padding: 0px 5px 20px 10px;
        text-decoration: none;
        font-size: 20px;
        color: rgb(175, 28, 64);
        display: block;
        transition: 0.5s;
        line-height: 1em;
        margin-top: 10px;

      }

      .dropdown-container{
        display:none;
      }

      /* color of text after hover*/
      .sidenav a:hover {
        color: #000000;
      }

      p
      /* what opens after clicking on an event */
      {
        font-size: 18px;
        padding-left: 35px;
        padding-right: 3px;
        padding-top: 0px;
        padding-bottom: 0px;
        color: #818181;
      }

      /*text specific for directions */
      .sidenav b {
        padding: 0px 5px 35px 35px;
        text-decoration: bold;
        font-size: 18px;
        color: #818181;
        display: block;
        transition: 0.3s;
      }
      /* color of text after hover*/
      .sidenav b:hover {
        color: #f1f1f1;
      }

      #main {
        transition: margin-left .5s;
        padding: 16px;
      }

      @media screen and (max-height: 450px) {
        .sidenav {padding-top: 15px;}
        .sidenav a {font-size: 18px;}
      }
    </style>
  </head>

<body>

  <div id="mySidenav" class="sidenavd">
  </div>

  <div id="mySidenav" class="sidenavc">
  <directions> click on a building to get directions </directions>
  </div>

  <div id="mySidenav" class="sidenavb">

  <g> EVENTS </g>
  <info> click on an event for directions or more information </info>
  </div>

  <div id="mySidenav" class="sidenav">

  <div class="button">
    <button id="authorize_button" style="display: none;">Authorize</button>
    <button id="signout_button" style="display: none;">Sign Out</button>
  </div>

  <pre id="content" style="white-space: pre-wrap;"></pre>

  <a class="dropdown-btn"> <div id ="event1"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time1"></p>
    <p id ="location1"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event2"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time2"></p>
    <p id ="location2"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event3"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time3"></p>
    <p id ="location3"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id ="event4"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time4"></p>
    <p id ="location4"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event5"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time5"></p>
    <p id ="location5"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event6"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time6"></p>
    <p id ="location6"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id ="event7"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time7"></p>
    <p id ="location7"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event8"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time8"></p>
    <p id ="location8"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event9"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time9"></p>
    <p id ="location9"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id ="event10"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time10"></p>
    <p id ="location10"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event11"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time11"></p>
    <p id ="location11"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event12"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time12"></p>
    <p id ="location12"></p>
    <b href="#">Directions</b>
  </div>
  <a class="dropdown-btn"> <div id ="event13"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time13"></p>
    <p id ="location13"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event14"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time14"></p>
    <p id ="location14"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event15"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time15"></p>
    <p id ="location15"></p>
    <b href="#">Directions</b>

    <a class="dropdown-btn"> <div id="event16"></div>
      <i class="fa fa-caret-down"></i>
    </a>
    <div class="dropdown-container">
      <p id ="time16"></p>
      <p id ="location16"></p>
      <b href="#">Directions</b>
    </div>

    <a class="dropdown-btn"> <div id="event17"></div>
      <i class="fa fa-caret-down"></i>
    </a>
    <div class="dropdown-container">
      <p id ="time17"></p>
      <p id ="location17"></p>
      <b href="#">Directions</b>
    </div>
    <a class="dropdown-btn"> <div id ="event18"></div>
      <i class="fa fa-caret-down"></i>
    </a>
    <div class="dropdown-container">
      <p id ="time18"></p>
      <p id ="location18"></p>
      <b href="#">Directions</b>
    </div>

    <a class="dropdown-btn"> <div id="event19"></div>
      <i class="fa fa-caret-down"></i>
    </a>
    <div class="dropdown-container">
      <p id ="time19"></p>
      <p id ="location19"></p>
      <b href="#">Directions</b>
    </div>

    <a class="dropdown-btn"> <div id="event20"></div>
      <i class="fa fa-caret-down"></i>
    </a>
    <div class="dropdown-container">
      <p id ="time20"></p>
      <p id ="location20"></p>
      <b href="#">Directions</b>
  </div>



  <script>
    var dropdown = document.getElementsByClassName("dropdown-btn");
    var i;
    for (i = 0; i < dropdown.length; i++) {
      dropdown[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var dropdownContent = this.nextElementSibling;
        if (dropdownContent.style.display === "none") {
          dropdownContent.style.display = "block";
        } else {
          dropdownContent.style.display = "none";
        }
      });
    }
  </script>


  <script type="text/javascript">

    // Client ID and API key from the Developer Console
    var CLIENT_ID = '838924599001-deoloebt602et97hrlajsd29lmllnmpq.apps.googleusercontent.com';
    var API_KEY = 'AIzaSyDiUHhA9rZuyJyhTN5hjVPkwOQaCnC4zX4';

    // Array of API discovery doc URLs for APIs used by the quickstart
    var DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"];

    // Authorization scopes required by the API; multiple scopes can be
    // included, separated by spaces.
    var SCOPES = "https://www.googleapis.com/auth/calendar.readonly";

    var authorizeButton = document.getElementById('authorize_button');
    var signoutButton = document.getElementById('signout_button');
    //var xhr = new XMLHttpRequest();
    //xhr.open('GET', "https://www.googleapis.com/calendar/v3/calendars/acg4tehdnkv29rfpasrt7eo1kb81qv0l%40import.calendar.google.com/events?timeMax=2019-01-17T23%3A59%3A59Z&key={AIzaSyAbfHCvJAxKTcbFHJBtLjTdbiwKoq93vmc)", true);
    //xhr.send();
    /**
     *  On load, called to load the auth2 library and API client library.
     */
     var finalAthleticTitle = new Array();
     var finalAthleticLocation = new Array();
     var finalAthleticTimeD = new Array();
     var finalAthleticTimeH = new Array();
     var finalAthleticTimeM = new Array();
     var finalAthleticTimeYear = new Array();
     var finalAthleticTimeMonth = new Array();
     var finalAthleticTimeDay = new Array();
     var finalAthleticEndTimeH = new Array();
     var finalAthleticEndTimeM = new Array();

     var finalSchoolTitle = new Array();
     var finalSchoolLocation = new Array();
     var finalSchoolTimeD = new Array();
     var finalSchoolTimeH = new Array();
     var finalSchoolTimeM = new Array();
     var finalSchoolTimeYear = new Array();
     var finalSchoolTimeMonth = new Array();
     var finalSchoolTimeDay = new Array();
     var finalSchoolEndTimeH = new Array();
     var finalSchoolEndTimeM = new Array();

     var finalTitle = new Array();
     var finalLocation = new Array();
     var finalTimeD = new Array();
     var finalTimeH = new Array();
     var finalTimeM = new Array();
     var finalEndTimeH = new Array();
     var finalEndTimeM = new Array();

     var sPlace = 0;
     var aPlace = 0;

    function handleClientLoad() {
      gapi.load('client:auth2', initClient);
    }

    /**
     *  Initializes the API client library and sets up sign-in state
     *  listeners.
     */
    function initClient() {
      gapi.client.init({
        apiKey: API_KEY,
        clientId: CLIENT_ID,
        discoveryDocs: DISCOVERY_DOCS,
        scope: SCOPES
      }).then(function () {
        // Listen for sign-in state changes.
        gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);

        // Handle the initial sign-in state.
        updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
        authorizeButton.onclick = handleAuthClick;
        //signoutButton.onclick = handleSignoutClick;
      }, function(error) {
        appendPre(JSON.stringify(error, null, 2));
      });
    }

    /**
     *  Called when the signed in status changes, to update the UI
     *  appropriately. After a sign-in, the API is called.
     */
    function updateSigninStatus(isSignedIn) {
      if (isSignedIn) {
        authorizeButton.style.display = 'none';
        //signoutButton.style.display = 'block';
        listAthleticEvents();
        //listUpcomingEvents();
        //compileList();
      } else {
        authorizeButton.style.display = 'block';
        //signoutButton.style.display = 'none';
      }
    }

    /**
     *  Sign in the user upon button click.
     */
    function handleAuthClick(event) {
      gapi.auth2.getAuthInstance().signIn();
    }

    /*
     Sign out the user upon button click.
     */
    /*
    function handleSignoutClick(event) {
      gapi.auth2.getAuthInstance().signOut();
    }
    */

    /**
     * Append a pre element to the body containing the given message
     * as its text node. Used to display the results of the API call.
     *
     * @param {string} message Text to be placed in pre element.
     */
    function appendPre(message) {
      var pre = document.getElementById('content');
      var textContent = document.createTextNode(message + '\n');
      pre.appendChild(textContent);
    }

    /**
     * Print the summary and start datetime/date of the next ten events in
     * the authorized user's calendar. If no events are found an
     * appropriate message is printed.
     */
     //ATHLETIC EVENTS CALENDAR
     function listAthleticEvents() {
      gapi.client.calendar.events.list({
        'calendarId': 'ianftid1id99ndghk76k7fpab92vih89@import.calendar.google.com',
        'timeMin': (new Date()).toISOString(),
        'showDeleted': false,
        'singleEvents': true,
        'maxResults': 200,
        'orderBy': 'startTime'
      }).then(function(response) {
        console.log("Hello?");
        //final refined list to send to sidebar
        var aevents = response.result.items;
        //appendPre('Athletic events:');
        if (aevents.length > 0) {
          // if there are events on calendar execute to add space
          for (j = 0; j < aevents.length; j++) {
            var athletic = aevents[j];
            athletic.summary = athletic.summary + ' ';
            //appendPre(athletic.summary);
          }
          for (i = 0; i < aevents.length; i++) {
            var athletic = aevents[i];
            var awhen = athletic.start.dateTime;
            var aendwhen = athletic.end.dateTime;

            var today = (new Date()).toISOString();
            // grab the date of the instant it reloads and compare it to the date of the event
            var dateOnly = today.substring(8, 10);
            // take event's date and start time
            if (!awhen) {
              awhen = athletic.start.date;
            }
            // separate date, minutes, and seconds individually
            var startYear = awhen.substring(0, 4);
            var startMonth = awhen.substring (5, 7);
            var startDay = awhen.substring (8, 10);
            var startDate;
            var startMin = awhen.substring (14, 16);
            var startSec = awhen.substring (17, 19);

            if (aendwhen != null) {
              var endHours = aendwhen.substring (11, 13);
              var endMin = aendwhen.substring (14, 16);
            }

            //console.log(awhen);
            //console.log(aendwhen);
            //console.log(endHours);
            //console.log(endMin);
            // SWITCH TIMEZONES FROM UTC TO HST
            // get hours
            // add 10 hours to the time
            var startHours;
            startHours = awhen.substring (11, 13);

            // switch hours from UTC to HST
            startHours = startHours - 10;
            if (startHours < 0) {
              startHours = startHours + 24;
              startDay = startDay - 1;
            }
            endHours = endHours - 10;
            if (endHours < 0) {
              endHours = endHours + 24;
            }
            startDate = startYear + '-' + startMonth + '-' + startDay;
            // if today's date matches the event's date, print event
            if (dateOnly == startDay){
              // HSt is behind a day, so add 24 hours to get correct displayed hours
              startHours = startHours + 10;
              //appendPre(athletic.summary + ' (' + startDate + 'T' + startHours + ':' + startMin + ':' + startSec + 'Z' + ')' + ' (' + athletic.location + ')');
              if (athletic.location == 'Iolani' || athletic.location == "Ala Wai") {
                finalAthleticTitle[aPlace] = athletic.summary;
                finalAthleticLocation[aPlace] = athletic.location;
                finalAthleticTimeD[aPlace] = startDate;
                finalAthleticTimeH[aPlace] = startHours;
                finalAthleticTimeM[aPlace] = startMin;
                finalAthleticTimeYear[aPlace] = startYear;
                finalAthleticTimeMonth[aPlace] = startMonth;
                finalAthleticTimeDay[aPlace] = startDay;
                finalAthleticEndTimeH[aPlace] = endHours;
                finalAthleticEndTimeM[aPlace] = endMin;

                //appendPre(finalAthleticTitle[aPlace] + ' (' + finalAthleticTimeMonth[aPlace] + '-' + finalAthleticTimeDay[aPlace] + '-' + finalAthleticTimeYear[aPlace] + ')' + ' (' + finalAthleticTimeH[aPlace] + ':' + finalAthleticTimeM[aPlace] + ')' + '(' + finalAthleticLocation[aPlace] + ')' );
                aPlace = aPlace + 1;
              }
            }
          }
        }
        console.log("Athletics compiled");
        listUpcomingEvents();
      });
    }
    function listUpcomingEvents() {
      gapi.client.calendar.events.list({
        'calendarId': 'acg4tehdnkv29rfpasrt7eo1kb81qv0l@import.calendar.google.com',
        'timeMin': (new Date()).toISOString(),
    //    'timeMax': (new Date())
        'showDeleted': false,
        'singleEvents': true,
        'maxResults': 200,
        'orderBy': 'startTime'
      }).then(function(response) {
        var events = response.result.items;
        //imported array
        var checker = '';
        //placeholder to check individual words
        /*var omitTitle = new Array();
        var omitLocation = new Array("A-101", "A-102", "A-201", "A-202", "A-203", "Art Gallery",
                                     "C-100", "C-101", "C-102", "C-103", "C-104", "C-105", "C-106", "C-107", "C-108", "C-109", "C-110",
                                     "C-200", "C-201", "C-202", "C-203", "C-204", "C-205", "C-206", "C-207", "C-208", "C-209", "C-210",
                                     "G-101", "G-102", "Lower Gym", "Lower", "LG", "US Dance Room", "G-201", "G-202", "G-203", "Wrestling Room", "Upper Gym", "Upper", "UG",
                                     "I-101", "I-101L", "I-102", "I-102L", "I-103", "I-104", "I-105", "I-106", "I-107", "I-108", "I-109", "Writing Center", "I-110", "I-111", "ITS", "IT", "I-112",
                                     "I-201A", "I-201B", "I-202A", "I-202B", "I-203", "I-204", "I-205", "I-206", "I-207", "I-208", "I-209", "I-210", "I-211", "I-212", "I-213", "I-214", "I-215", "I-216", "I-217",
                                     "N-201", "N-202", "N-203", "N-204", "N-205", "N-206", "N-207", "N-208", "N-209", "N-210", "N-211",
                                     "R-101", "R-102",
                                     "SCIL-1", "SAO", "Student Activities Office", "Student Actvity Office", "Fab Lab", "Fabrication Lab", "I-Lab", "I Lab", "Ka'i Office", "Kai Office", "Senior Benches", "Sr. Benches",
                                     "SCIL-2", "Library", "Archives",
                                     "SCIL-3", "3", "SCIL-3 CC", "CC", "SCIL-3 Seminar Room", "SCIL-3 SR", "SR",
                                     "SCIL-4", "4", "SCIL-4 CSC", "CSC", "SCIL-4 DDS", "DDS", "SCIL-4 Wetlab", "Wetlab", "Wet lab",
                                     "W-101", "W-102", "W-103", "W-104", "W-105", "W-106", "College Counseling Office", "CCO", "College Counseling",
                                     "W-201", "W-202", "W-203", "W-204", "W-205", "W-206", "W-207", "W-208", "W-209", "W-210", "W-211", "W-212", "W-213", "W-214", "W-215", "W-216",
                                     "W-301", "W-302", "W-303", "W-304", "W-305", "W-306", "W-307", "W-308", "W-309", "W-310", "W-311", "W-312", "W-313", "W-314", "W-315", "W-316",
                                     "Seto Hall", "Seto", "Seto Hall Lanai", "Seto Lanai",
                                     "Student Center", "SC", "Cafeteria", "Fac. Lounge", "Faculty Lounge", "Kitchen",
                                     "Pool", "Dillingham Pool",
                                     "Football Field", "Track", "Soccer Field", "Kozuki Stadium", "Press Box",
                                     "Chapel", "St. Alban's Chapel",
                                     "Center Courtyard");*/

        //varibles to check event with
        //appendPre('');
        //appendPre('School Events:');

        if (events.length > 0) {
          // if there are events on calendar execute
          for (j = 0; j < events.length; j++) {
            var school = events[j];
            school.summary = school.summary + ' ';
            //appendPre(school.summary);
          }
          // create a space between each event
          for (i = 0; i < events.length; i++) {
            // run through every event in list
            var school = events[i];
            // "event" variable is the current event in the array
            for (u = 0; u < school.summary.length; u++) {
              // variable u to run through characters of each event
              checker = checker + school.summary[u];
              //appendPre(checker);
              // placeholder variable that contains all current characters for loop when through
              if (school.summary[u] == ' ' || u >= school.summary.length) {
                // if it encounters a space
                if (checker == 'Trip ' || checker == 'Faculty ' || checker == 'Faculty/Staff ' || checker == 'Fac/Staff ' || checker == 'Staff/Faculty ' ||
                checker == 'Staff/Fac ' || checker == 'Assembly ' || checker == 'AATF ' || checker == 'TIAA ' || checker == 'IAA ' || checker == 'Admission ' ||
                checker == "Advisors' " || checker == "Heads' " || checker == 'Advisory ' || checker == 'ASC ') {
                  //if the word reads any of the above words, erase summary
                  school.summary = '';
                  school.location = '';
                 //MAKE AP GOV. CHANGE
                }
                checker = '';
                // set placeholder back to blank for next word if there is one
              }
            }
            if (!school.location) {
              // if the event has no location, delete array portion
              school.summary = '';
              school.start.dateTime = '';
              school.location = '';
            }

            if (school.location != '' && school.summary != '') {
              //appendPre(school.summary);
              // if the event has a location and summary keep
              var when = school.start.dateTime;
              var endwhen = school.end.dateTime;
              var today = (new Date()).toISOString();
              // grab the date of the instant it reloads and compare it to the date of the event
              var dateOnly = today.substring(8, 10);
              // take event's date and start time
              if (!when) {
                // if there is no start time, put date for all day event
                when = school.start.date;
              }

              //appendPre(finalSchoolTitle[i] + ' ' +  ' (' + finalSchoolTime[i] + ')' + ' (' + finalSchoolLocation[i] + ') ');
              // print the event
              var startYear = when.substring(0, 4);
              var startMonth = when.substring (5, 7);
              var startDay = when.substring (8, 10);
              var startDate;
              var startMin = when.substring (14, 16);
              var startSec = when.substring (17, 19);

              if (endwhen != null) {
                var endHours = endwhen.substring (11, 13);
                var endMin = endwhen.substring (14, 16);
              }

              // SWITCH TIMEZONES FROM UTC TO HST
              // get hours
              // add 10 hours to the time
              var startHours;
              startHours = when.substring (11, 13);

              //if (startHours > 0 && startHours < 34 && startDay == dateOnly) {
              //  startDay = startDay - 1;
              //}
              // switch hours from UTC to HST
              startHours = startHours - 10;
              if (when != school.start.date) {
                if (startHours < 0) {
                  startHours = startHours + 24;
                  startDay = startDay - 1;
                }
                endHours = endHours - 10;
                if (endHours < 0) {
                  endHours = endHours + 24;
                }
              }
              //if (startHours != null) {
              //  console.log(school.summary);
              //  startDay = startDay + 1;
              //}
              startDate = startYear + '-' + startMonth + '-' + startDay;
              // if today's date matches the event's date, print event
              //appendPre(school.summary + ' (' + startDate + 'T' + startHours + ':' + startMin + ':' + startSec + 'Z' + ')' + ' (' + school.location + ')');
              if (dateOnly == startDay){
                // HSt is behind a day, so add 24 hours to get correct displayed hours
                //appendPre(school.summary + ' (' + startDate + 'T' + startHours + ':' + startMin + ':' + startSec + 'Z' + ')' + ' (' + school.location + ')');
                if (school.location != '') {
                  finalSchoolTitle[sPlace] = school.summary;
                  finalSchoolLocation[sPlace] = school.location;
                  finalSchoolTimeD[sPlace] = startDate;
                  finalSchoolTimeH[sPlace] = startHours;
                  finalSchoolTimeM[sPlace] = startMin;
                  finalSchoolTimeYear[sPlace] = startYear;
                  finalSchoolTimeMonth[sPlace] = startMonth;
                  finalSchoolTimeDay[sPlace] = startDay;
                  finalSchoolEndTimeH[sPlace] = endHours;
                  finalSchoolEndTimeM[sPlace] = endMin;
                  //appendPre(finalSchoolTitle[sPlace] + ' (' + finalSchoolTimeMonth[sPlace] + '-' + finalSchoolTimeDay[sPlace] + '-' + finalSchoolTimeYear[sPlace] + ')' + ' (' + finalSchoolTimeH[sPlace] + ':' + finalSchoolTimeM[sPlace] + ')' + '(' + finalSchoolLocation[sPlace] + ')' );
                  sPlace = sPlace + 1;
                }
            }
          }
        }
        } else {
          appendPre('No upcoming events found.');
        }
        var today = new Date();
        //appendPre(today.getMonth());
        console.log("School compiled");
        compileList();
      });
    }

    function compileList() {
      //appendPre(today);
      //appendPre("");
      //appendPre("COMPLIED LIST:");
      var a = 0;
      var s = 0;

      for (i = 0; i < sPlace; i++) {
        //appendPre(finalSchoolTitle[i] + ' ' +  ' (' + finalSchoolTimeD[i] + ' ' + finalSchoolTimeH[i] + ':' + finalSchoolTimeM[i] + ') (' + finalSchoolLocation[i] + ') ');
      }

      //appendPre("");

      for (i = 0; i < aPlace; i++) {
        //appendPre(finalAthleticTitle[i] + ' ' +  ' (' + finalAthleticTimeD[i] + ' ' + finalAthleticTimeH[i] + ':' + finalAthleticTimeM[i] + ') (' + finalAthleticLocation[i] + ') ');
      }

      //appendPre("");

      for (i = 0; i < 200; i++) {
        //when there is no school events remaining to be sorted
        //console.log("Comparing: " + finalSchoolTimeYear[s] + " " + finalAthleticTimeYear[a]);
        //console.log("Comparing: " + finalSchoolTimeMonth[s] + " " + finalAthleticTimeMonth[a]);
        //console.log("Comparing: " + finalSchoolTimeDay[s] + " " + finalAthleticTimeDay[a]);
        //console.log("Comparing: " + finalSchoolTimeH[s] + " " + finalAthleticTimeH[a]);
        //console.log("Comparing: " + finalSchoolTimeM[s] + " " + finalAthleticTimeM[a]);
        if (finalSchoolTitle[s] == null && finalAthleticTitle[a] != null) {
            finalTimeD[i] = finalAthleticTimeD[a];
            finalTimeH[i] = finalAthleticTimeH[a];
            finalTimeM[i] = finalAthleticTimeM[a];
            finalTitle[i] = finalAthleticTitle[a];
            finalLocation[i] = finalAthleticLocation[a];
            finalEndTimeH[i] = finalAthleticEndTimeH[a];
            finalEndTimeM[i] = finalAthleticEndTimeM[a];
            a = a + 1;
            //console.log("Athletic Event, no school");
            //appendPre("Placing remaining athletic event: " + finalTitle[i]);
        }
        //when there is no athletic events remaining to be sorted
        else if (finalAthleticTitle[a] == null && finalSchoolTitle[s] != null) {
          finalTimeD[i] = finalSchoolTimeD[s];
          finalTimeH[i] = finalSchoolTimeH[s];
          finalTimeM[i] = finalSchoolTimeM[s];
          finalTitle[i] = finalSchoolTitle[s];
          finalLocation[i] = finalSchoolLocation[s];
          finalEndTimeH[i] = finalSchoolEndTimeH[s];
          finalEndTimeM[i] = finalSchoolEndTimeM[s];
          s = s + 1;
          //console.log("School Event, no athletic");
          //appendPre("Placing remaining school event: " + finalTitle[i]);
        }
        //when school event is before athletic event
        else if ((finalSchoolTimeYear[s] <= finalAthleticTimeYear[a]) &&
            (finalSchoolTimeMonth[s] <= finalAthleticTimeMonth[a]) &&
            (finalSchoolTimeDay[s] <= finalAthleticTimeDay[a]) &&
            (finalSchoolTimeH[s] <= finalAthleticTimeH[a])) {
          //appendPre("compare school");
          finalTimeD[i] = finalSchoolTimeD[s];
          finalTimeH[i] = finalSchoolTimeH[s];
          finalTimeM[i] = finalSchoolTimeM[s];
          finalTitle[i] = finalSchoolTitle[s];
          finalLocation[i] = finalSchoolLocation[s];
          finalEndTimeH[i] = finalSchoolEndTimeH[s];
          finalEndTimeM[i] = finalSchoolEndTimeM[s];
          s = s + 1;
          //console.log("School Event, yes athletic");
          //appendPre("s: " + s);
        }
        //when athletic event is before school event
        else if (finalAthleticTitle[a] != null && finalSchoolTitle[s] != null) {
          //appendPre("compare athletic");
          finalTimeD[i] = finalAthleticTimeD[a];
          finalTimeH[i] = finalAthleticTimeH[a];
          finalTimeM[i] = finalAthleticTimeM[a];
          finalTitle[i] = finalAthleticTitle[a];
          finalLocation[i] = finalAthleticLocation[a];
          finalEndTimeH[i] = finalAthleticEndTimeH[a];
          finalEndTimeM[i] = finalAthleticEndTimeM[a];
          a = a + 1;
          //console.log("Athletic Event, yes school");
          //appendPre("a: " + a);
        }
        //when all events are done
        else if (finalAthleticTitle[i] == null && finalSchoolTitle[i] == null) {
          //appendPre("FINAL LIST:");
          //console.log("DONE");
          for (c = 0; c < i; c++) {
            //start and end times are both pm
            if ((finalTimeH[c] >= 12) && (finalEndTimeH[c] >= 12)) {
              if (finalEndTimeH[c] == 12){
                finalTimeH[c] = (finalTimeH[c] - 12) + ':' + finalTimeM[c] + ' p.m.' + ' to ' + (finalEndTimeH[c]) + ':' + finalEndTimeM[c] + ' p.m.';
              }
              else if (finalTimeH[c] == 12) {
                finalTimeH[c] = (finalTimeH[c]) + ':' + finalTimeM[c] + ' p.m.' + ' to ' + (finalEndTimeH[c] - 12) + ':' + finalEndTimeM[c] + ' p.m.';
              }
              else {
                finalTimeH[c] = (finalTimeH[c] - 12) + ':' + finalTimeM[c] + ' p.m.' + ' to ' + (finalEndTimeH[c] - 12) + ':' + finalEndTimeM[c] + ' p.m.';
                //console.log(finalTimeH[c]);
              }
            }
            //start time pm but end time is am
            else if ((finalTimeH[c] >= 12) && (finalEndTimeH[c] < 12)) {
              finalTimeH[c] = (finalTimeH[c] - 12) + ':' + finalTimeM[c] + ' p.m.' + ' to ' + (finalEndTimeH[c]) + ':' + finalEndTimeM[c] + ' a.m.';
              //console.log(finalTimeH[c]);
            }
            //start time is am but end time is pm
            else if ((finalTimeH[c] < 12) && (finalEndTimeH[c] >= 12)) {
              if (finalEndTimeH[c] == 12){
                finalTimeH[c] = (finalTimeH[c]) + ':' + finalTimeM[c] + ' a.m.' + ' to ' + (finalEndTimeH[c]) + ':' + finalEndTimeM[c] + ' p.m.';
              }
              else {
                finalTimeH[c] = (finalTimeH[c]) + ':' + finalTimeM[c] + ' a.m.' + ' to ' + (finalEndTimeH[c] - 12) + ':' + finalEndTimeM[c] + ' p.m.';
                //console.log(finalTimeH[c]);
              }
            }
            //start and end times are both am
            else {
              finalTimeH[c] = finalTimeH[c] + ':' + finalTimeM[c] + ' a.m.' + ' to ' + finalEndTimeH[c] + ':' + finalEndTimeM[c] + ' a.m.';
              //console.log(finalTimeH[c], "TIMES"); /*--------------START HERE-----------------*/
            }
            if (finalTimeM[c] == '') {

              finalTimeH[c] = 'All Day';
              finalTimeM[c] = '';
            }
            //appendPre(finalTitle[c] + ' ' +  ' (' + finalTimeD[c] + ' ' + finalTimeH[c] + ':' + finalTimeM[c] + ') (' + finalLocation[c] + ') ');
            console.log("Ordering Complete");
            //listing all the events
            for (var i = 0; i < finalTitle.length; i++){
              var firstEvent = "event" + i;
              var secondEvent = "event" + (i + 1);
              var newEvent = firstEvent.replace(firstEvent.toString(),secondEvent.toString());
              document.getElementById(newEvent).innerHTML = finalTitle[i];
            }

            //listing all the locations
            for (var i = 0; i < finalLocation.length; i++){
              var firstLocation = "location" + i;
              var secondLocation = "location" + (i + 1);
              var newLocation = firstLocation.replace(firstLocation.toString(),secondLocation.toString());
              document.getElementById(newLocation).innerHTML = finalLocation[i];
            }
            //listing all the times
            for (var i = 0; i < finalTimeH.length; i++){
              var firstTime = "time" + i;
              var secondTime = "time" + (i + 1);
              var newTime = firstTime.replace(firstTime.toString(),secondTime.toString());
              document.getElementById(newTime).innerHTML = finalTimeH[i];
            }
          }
          i = 200;
        }
      }
    }
  </script>

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
  <script type="text/javascript">
  jQuery(function($){
  	var images = ['2picturescreensaver.jpg', 'screensaver2-01.jpg', 'screensaver3-01.jpg', 'screensaver4-01.jpg'],
  	timebeforesleep = 2000, //milliseconds inactivity before sleep
  	imagedisplaytime = 10000, //nilliseconds each image shown during sleep
  	$sleeper = $('<div style="display: none; width: 100%; height: 100%; background-color: black; position: fixed; top: 0; right: 0;">' +
  		'<img src="' + images[0] + '"style="width: 100%; height: 100%; display: block;" width="100%" height="100%" alt="Click or Press Key to Return Image" title="Click or Press Key to Return"></div>')
  		.appendTo(document.body), timer, nofixed, scroll, preloads = [], imcounter = 0, ie7 = /MSIE (\d+)/.exec(navigator.userAgent), imginterval;
  		if(ie7 && ie7[1] < 8){
  			$sleeper.css({position: 'absolute'});
  			nofixed = true;
  		}
  	$.each(images, function(i, im){ //preload
  		$(new Image()).on('load error', function(e){
  			preloads[i] = e.type;
  		}).attr('src', im);
  	});
  	function rotateimage(){
  		imcounter = (imcounter + 1) % images.length;
  		if(!preloads[imcounter] || preloads[imcounter] === 'error'){ //skip missing images and those not yet loaded
  			rotateimage();
  			return;
  		}
  		$sleeper.find('img').attr('src', images[imcounter]);
  	}
  	$(document).on('mousemove click keydown touchstart focusin', function(){
  		clearTimeout(timer);
  		clearInterval(imginterval);
  		preparetosleep();
  		if($sleeper.css('display') !== 'none'){
  			$sleeper.stop(true, true).hide('slow', function(){
  				if(scroll = $sleeper.data('scroll')){$(window).scrollTop(scroll[1]); $(window).scrollLeft(scroll[0]);}
  			});
  			$('html, body').css({width: '', height: '', margin: '', padding: '', overflow: ''});
  		}
  	});
  	function preparetosleep(){
  		timer = setTimeout(function(){
  			clearInterval(imginterval);
  			imginterval = setInterval(rotateimage, imagedisplaytime);
  			$sleeper.data('scroll', [$(window).scrollLeft(), $(window).scrollTop()]);
  			$('html, body').css({width: nofixed? $(window).width() : '100%', height: nofixed? $(window).height(): '100%', margin: 0, padding: 0, overflow: 'hidden'});
  			$sleeper.stop(true, true).show('slow');
  		}, timebeforesleep);
  	}
  	preparetosleep();
  });
  </script>

  <script async defer src="https://apis.google.com/js/api.js"
    onload="this.onload=function(){};handleClientLoad()"
    onreadystatechange="if (this.readyState === 'complete') this.onload()">
  </script>

  <script>
    //width of sidebar
    /*
    function openNav() {
      document.getElementById("mySidenav").style.width = "700px";
      document.getElementById("main").style.marginLRight = "500px";
    }
    style.marginR
    function closeNav() {
      document.getElementById("mySidenav").style.width = "0";
      document.getElementById("main").style.marginLRight= "0";
    }
    */
<<<<<<< HEAD

=======
>>>>>>> 158551b41d60764c52017f54172a58f366ff25d7
      </script>

        <script src="js/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/loaders/GLTFLoader.js"></script>
        <script src="js/shaders/CopyShader.js"></script>
        <script src="js/shaders/FXAAShader.js"></script>
        <script src="js/postprocessing/EffectComposer.js"></script>
        <script src="js/postprocessing/RenderPass.js"></script>
        <script src="js/postprocessing/ShaderPass.js"></script>
        <script src="js/postprocessing/OutlinePass.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src='js/libs/dat.gui.min.js'></script>
        <script src='js/NameList.js'></script>
        <script src="js/loaders/OBJLoader.js"></script>
        <div id = 'canvas'>
          <script>
          // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277

          // heap clears frequently, nodes do not

          // use this function to interact with JavaScript from sidebar interaction
          const changeText = () => {}

        //to do list here

        // declaring big boy variables
        var t;
        var container, stats;
        var camera, scene, renderer, controls;
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var selectedObjects = [];
        var composer, effectFXAA, outlinePass;
        var group = new THREE.Group();
        var obj3d = new THREE.Object3D();
        var clips;
        var mixer = new THREE.AnimationMixer();
        var clock = new THREE.Clock(true);
        var divWidth = window.innerWidth;
        var divHeight = window.innerHeight;
        var objloader = new THREE.OBJLoader();

        var dots = new Array();
        var radius = 5;
        var convtxs = new Float32Array();
        var dotlength;
        var linee;

        var geometr = new THREE.BoxGeometry( radius, radius, radius);
        var materia = new THREE.MeshLambertMaterial( {color: 0xff0000} );
        var spher = new THREE.Mesh( geometr, materia );

        var geometrt = new THREE.BoxGeometry( 5, 2);
        var materiaa = new THREE.MeshLambertMaterial( {color: 0xff0000} );
        var spherer = new THREE.Mesh( geometrt, materiaa );

        var nucurve;


        var ie;
        var curvee = new THREE.CatmullRomCurve3();
        var pieces = 5;

        var curveArray = new Array();
        var curveEqArray = Array();
        var curvesToAdd = Array();
        var cuvesToAni = Array();

        var matt = new THREE.LineBasicMaterial( { color : 0x00ff00, linecap: 'square', linejoin: 'square', linewidth: 5 } );

        var totaldots = 1000;

        function findRoom (stringg)
        {

        }


        function dot (u)
        {
          var geometr = new THREE.BufferGeometry();
          var ohold;
          objloader.load(
          // resource URL
          'models/arruw.obj',
          // called when resource is loaded
          function ( object ) {

            ohold = object.children[0].geometry;

            var materia = new THREE.MeshBasicMaterial( {color: 0xff0000} );
            var lxl;
            for (lxl = 0; lxl < u; lxl++)
            {
              dots[lxl] = new THREE.Mesh( ohold, materia );
              //dots[lxl].material.visible = true;
              dots[lxl].position.y = 42069360;
              scene.add(dots[lxl]);

              //console.log(lxl, dots[lxl]);
              //scene.add(dots[lxl]);
              dotlength = dots.length;
            }
            console.log(dots.length);

          } );

          console.log(dots.length, "asdf");
        }

        function indexDown (index)
        {
          if (index != 0)
          {
            return index - 1;
          }
          return 0;
        }


        function comppts (q, arr, index)
        {
          var curveptarray = new Array();
          for (ie = 0; ie < (q / 3) - 1; ie++)
          {
            if (ie % pieces == 0)
            {
              curveptarray[ie/pieces] = new THREE.Vector3(arr[ie * 3], arr[ie * 3 + 1], arr[ie * 3 + 2]);
            }
          }
          curveEqArray[index] = new THREE.CatmullRomCurve3();
          curveEqArray[index].points = curveptarray;
          //scene.add( curveEqArray[index] );
          //curveptarray = new Array();

          console.log("help", index);
          console.log("help", curveEqArray[index]);
        }

        function spSetup(roomLink, id, stScale, yScale, xp, yp, zp)
        {
          objloader.load(
          // resource URL
          'models/curves/' + roomLink + '.obj',
          // called when resource is loaded
          function ( object ) {
            nucurve = new THREE.Line(object, matt);
            comppts(object.children[0].geometry.attributes.position.array.length, object.children[0].geometry.attributes.position.array, id);
            var toobg = new THREE.TubeBufferGeometry( curveEqArray[id], 100, .03, 4, false );
            var toobm = new THREE.MeshBasicMaterial( { color: 0xff0000} );
            curveArray[id] = new THREE.Mesh( toobg, toobm );
            curveArray[id].scale.x = stScale;
            curveArray[id].scale.y = stScale;
            curveArray[id].scale.z = stScale;
            curveArray[id].position.x = xp;
            curveArray[id].position.y = yp;
            curveArray[id].position.z = zp;
            curveArray[id].name = roomLink;
            console.log("COOKIE", curveArray[id]);
            scene.add( curveArray[id] );
          });
        }

        function sepCurve ()
        {

        }

        function init2 ()
        {
          spSetup('C-101', 0, 1, 1, 1, 0, 50);
        }

      init();
      onWindowResize();
      animate();

      function init()
      {
        //startClosed();

        container = document.getElementById( 'canvas' );
        document.body.appendChild( container );

        renderer = new THREE.WebGLRenderer({ alpha: true });
        container.appendChild( renderer.domElement );


        // set to cutout size in the future
        var width = divWidth;
        var height = divHeight;

        // enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;

        // initialize scene
        scene = new THREE.Scene();


        // initialize and position camera
         camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
        camera.position.set( 0, 0, 0 );

        // initialize and customize controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 20;
        controls.maxDistance = 40;
        controls.maxPolarAngle = 9.7*Math.PI/24;
        //controls.minPolarAngle = 0;
        controls.enablePan = true;
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.target.x =  1;
        controls.enableZoom = true;
        //

        // add ambient light
        scene.add( new THREE.AmbientLight( 0xffffff, .7 ) );

        /*
        var light = new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0, 500, 200);
        light.target.position.set(0, 0, 0);
        light.shadow.mapSize.width = 1024*4;
        light.shadow.mapSize.height = 1024*4;
        light.castShadow = true;

        light.shadow.camera.near = 0;
        light.shadow.camera.far = 4000;
        light.shadow.camera.fov = 90;
        */



































        /*
        *Model Loaders
        */
        //Todo Add Import for splines from Braxton
        /*
        *Main function to load in the school model.
        *path takes a string of the file path of the model (GLTF format)
        *position takes a Vector3 and sets the the model centered to that position
        *modelGroup takes a Group and makes it the top of the tree
        *Each mesh in the model is added to a group based on the scene that it is in
        *each scene is then added to modelGroup
        *
        *The tree is divided by Building, floor, and room.
        *Each Section has splines assigned to it used for pathfinding
        *
        *                     Outline of tree system
        *
        * Main Group -> Buildings - > Floors - > Rooms
        *                   |            |         |
        *"Highway" Splines to entrance   |         |
        *         Splines From Entrance to floor   |
        *                       Splines from stairway / floor Entrance to room
        */
        var loader = new THREE.GLTFLoader();

        function loadCampus(path, position, modelGroup){
          loader.load( path, function ( gltf )
          {
            clips = gltf.animations;
            /*
            *Each Scene is named a 1 letter code for what building it represents
            *E.G. Weinberg is W, Nangaku is N
            */
            gltf.scenes.forEach(function (curScene){
              var buildingGroup = new THREE.Group();
              buildingGroup.name = curScene.name;
              var sceneLength = curScene.children.length;
              /*
              *Creates 4 floors for each Building, not all are used
              *each room is stored in its floor,
              *Each floor is assigned a name e.g  N2 and a pathfinding line
              */
              var floor1 = new THREE.Group();
              buildingGroup.add(floor1);
              floor1.name = buildingGroup.name + "1";

              var floor2 = new THREE.Group();
              buildingGroup.add(floor2);
              floor2.name = buildingGroup.name + "2";

              var floor3 = new THREE.Group();
              buildingGroup.add(floor3);
              floor3.name = buildingGroup.name + "4";

              var floor4 = new THREE.Group();
              buildingGroup.add(floor4);
              floor4.name = buildingGroup.name + "4";

              var floor5 = new THREE.Group();
              buildingGroup.add(floor5);
              floor5.name = buildingGroup.name + "5";

              /*
              *Each mesh has a prefix indicating the building it is a part of and the floor
              *e.g. N2 means Nangaku second floor
              *Each room is named after its room number e.g. N203 or N204
              *Each non room mesh is named with its prefix and followed by part
              */
              for(var i = 0; i < sceneLength; i++){
                switch (curScene.children[0].name.slice(1,2)) {
                  case "1":
                    floor1.add(curScene.children[0]);
                    break;

                  case "2":
                    floor2.add(curScene.children[0]);
                    break;

                  case "3":
                    floor3.add(curScene.children[0]);
                    break;

                  case "4":
                    floor4.add(curScene.children[0]);
                    break;

                  case "5":
                    floor5.add(curScene.children[0]);
                    break;

                  default:
                    floor1.add(curScene.children[0]);
                }
              }
              buildingGroup.children.forEach( function (child){
                child.children.forEach(function(room){
                  if (room instanceof THREE.Mesh){
                    room.receiveShadow = true;
                    room.castShadow = true;
                    room.material.side = THREE.DoubleSide;
                    room.geometry.computeBoundingSphere();

                    //tests if the mesh is a room or just an aesthetic part
                    if(room.name.slice(2, -3) == 'part'){
                      //Adds custom object containing if it is a selectable room and if it is already animated and the name(s) of the room
                      room.userData = {alreadyUp:false, isRoom:false, isRestroom:false};
                    }
                    //tests if mesh is stairs, stairs must use special animation
                    else if (room.name.slice(2, -3) == 'Restroom'){
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:true};
                    }
                    else{
                      //Accesses a list of names and adds each one to the model
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:false, names:findNames(child.name)};
                    }
                    if(room.userData.isRestroom){
                      createRestroom(room.position);
                    }
                  }

                 else if (room instanceof THREE.Group){
                    room.children.forEach(function(children){
                      children.receiveShadow = true;
                      children.castShadow = true;
                      children.geometry.computeBoundingSphere();
                      children.material.side = THREE.DoubleSide;
                    });

                    //tests if the mesh is a room or just an aesthetic part
                    if(room.name.slice(2, -3) == 'part'){
                      //Adds custom object containing if it is a selectable room and if it is already animated and the name(s) of the room
                      room.userData = {alreadyUp:false, isRoom:false, isRestroom:false};
                    }
                    //tests if mesh is stairs, stairs must use special animation
                    else if (room.name.slice(2, -3) == 'Restroom'){
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:true};
                    }
                    else{
                      //Accesses a list of names and adds each one to the model
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:false, names:findNames(child.name)};
                    }
                    if(room.userData.isRestroom){
                      createRestroom(room.position);
                    }
                  }

                });
              });
              modelGroup.add(buildingGroup);
            });
          });
          modelGroup.position.copy(position);
        }

        // add Nangaku model
        loadCampus('models/CampusFinalMapV2.gltf', new THREE.Vector3(1,0.1,50), group);
        console.log(group);

        controls.target = new THREE.Vector3(1, 0, 50);

        //add the group of all models into the scene
        scene.add( group );



        init2();
        dot(totaldots);

        // add and position floor

        var floorMaterial = new THREE.MeshPhongMaterial({color: 0xbbff96});
        var floorGeometry = new THREE.PlaneBufferGeometry(10000, 10000);

        floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        scene.add(floorMesh);
        floorMesh.rotation.x -= Math.PI * 0.5;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        floorMesh.castShadow = true;

        // initialize postprocessing
        composer = new THREE.EffectComposer( renderer );
        var renderPass = new THREE.RenderPass( scene, camera );
        composer.addPass( renderPass );
        outlinePass = new THREE.OutlinePass( new THREE.Vector2( divWidth, divHeight ), scene, camera );
        composer.addPass( outlinePass );

        // initialize antialiasing
        effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );

        //Function to take the name of a selected Room

        function getRoomName(room){
          if(room.name.slice(0,1) == 'M'){
            return room.parent.name;
          }
          else return room.name
        }

        //Takes a position and creates a restroom sign at that position, used by loader

        var restroomSignMap = new THREE.TextureLoader().load( "Sprites/RestroomSign.png" );
        var restroomSignMaterial = new THREE.SpriteMaterial( { map: restroomSignMap, color: 0xffffff } );

        function createRestroom(position){
          var restroomSign = new THREE.Sprite( restroomSignMaterial );
          restroomSign.scale = new THREE.Vector3(10,10,10);
          restroomSign.position.copy(position);
          restroomSign.position.y = restroomSign.position.y + 1;

          group.add( restroomSign );
        }

        /*
        * Animation Functions
        */

        //given a name and am object plays an animation
        function playAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.play();
        }

        function stopAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.stop();
        }

        //plays animation on a object forwards or backwards stopping on last frame
        function playFloorAnimation( rootObject, isUp, clipName ){

          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );

          action.clampWhenFinished = true;
          action.setLoop(THREE.LoopOnce);

          if(isUp){
            action.timeScale = -1;
          }

          else{action.timeScale = 1;}
          rootObject.alreadyUp = !rootObject.alreadyUp;
          action.play();
          action.paused = false;
        }

        /*
        *Animates all floors in the building Group
        *putting 'pingPong' for animation mode toggles the animation Up and down
        * 'lower' only lowers the floors if they are up
        *'raise' raises the floors if they are dowb.
        */

        function animateFloors(selectedRoom, animationMode){
          if(animationMode  == 'PingPong'){
            selectedRoom.parent.parent.children.forEach(function(child){
              child.children.forEach(function(room){
                //plays animations by the name of the floors, each floor's suffix has a matching animation
                if (THREE.AnimationClip.findByName(clips,room.name.slice(0, -3)) != null){
                  playFloorAnimation(room, room.alreadyUp, room.name.slice(0, -3));
                }
                else{room.alreadyUp = !room.alreadyUp;}
              });
            });
          }

          else if(animationMode == 'Lower'){
            selectedRoom.parent.parent.children.forEach(function(child){
              child.children.forEach(function(room){
                //plays animations by the name of the floors, each floor's suffix has a matching animation
                if (THREE.AnimationClip.findByName(clips,room.name.slice(0, -3)) != null){
                  playFloorAnimation(room, true, room.name.slice(0, -3));
                }

                else{room.alreadyUp = false;}
              });
            });
          }

          else if (animationMode == 'Raise') {
            selectedRoom.parent.parent.children.forEach(function(child){
              child.children.forEach(function(room){
                //plays animations by the name of the floors, each floor's suffix has a matching animation
                if (THREE.AnimationClip.findByName(clips,room.name.slice(0, -3)) != null){
                  playFloorAnimation(room, false, room.name.slice(0, -3));
                }
                else{room.alreadyUp = true;}
              });
            });
          }
          else {console.log("Invalid Input, use pingPong, raise, or lower")}
        }

        // initialize event listeners
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mouseup', onTouchMove );
        window.addEventListener( 'touchend', onTouchMove );
        window.addEventListener( 'touchstart', onmesh);
        window.addEventListener( 'mousedown', onmesh);
        //window.addEventListener( 'mousemove', stopstart);

        // variables for listener functions
        var clicked = true;
        var started = false;
        var lfclick = true;
        var prevobj = null;

        /////////////////////////////////
        //  event triggered functions  //
        /////////////////////////////////
        function onmesh (event)
        {
          var x, y;

          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;

          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            started = true;
          }
          else
          {
            started = false;
          }

          // put opennav where

        }

        // checks intersection when click up
        function onTouchMove( event )
        {
          var x, y;
          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;
          checkIntersection();
        }

        // adds object to outline list
        function addSelectedObject( object )
        {
          selectedObjects = [];
          selectedObjects.push( object );
        }

        function checkIntersection()
         {
           raycaster.setFromCamera( mouse, camera );
           var intersects = raycaster.intersectObjects( [ group ], true );
           if ( intersects.length > 0 )
           {
             outlinePass.selectedObjects = [];
             var selectedObject = intersects[ 0 ].object;

             if(getRoomName(selectedObject).slice(2,-3) != 'part'){
               addSelectedObject( selectedObject );
             }

             animateFloors(selectedObject, 'PingPong');


             if (clicked && started || prevobj != selectedObject)
             {
               outlinePass.selectedObjects = selectedObjects;
               openNav();
             }
             else
             {
               outlinePass.selectedObjects = [];
               closeNav();
             }
             clicked = !clicked;
           }
           else
           {
             if (!started)
             {
               outlinePass.selectedObjects = [];
             }
           }
           prevobj = selectedObject;
         }


        var width = divWidth;
        var height = divHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize( width, height );
        composer.setSize( width, height );
        renderer.domElement.style.width = width + 'px';
        renderer.domElement.style.height = height + 'px';
      }



        // resize the screen correctly
        var i = 0;
        function onWindowResize()
        {
          divWidth = window.innerWidth;// / 2;
          divHeight = window.innerHeight; // 2;
          var width = divWidth;
          var height = divHeight;
          var w2 = 0;//200/7;//= xx;
          var h2 = 0;//= yy;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize( width, height );
          composer.setSize( width, height );
          renderer.domElement.style.width = width + 'px';
          renderer.domElement.style.height = height + 'px';
          //renderer.domElement.style.offsetLeft = w2 + 'px';
          //renderer.domElement.style.offsetTop = h2 + 'px';
          effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );


          var css = '#canvas {background-color: #f0f; margin-left: ' + w2.toString() + 'vw; width: 0px; height: 0px; padding: 0px; margin-top: ' + h2.toString() + 'vw; position: static;}',
          head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');

          var y;


          style.type = 'text/css';
          if (style.styleSheet)
          {
            // This is required for IE8 and below.
            style.styleSheet.cssText = css;
          }
          else
          {
            t = document.createTextNode(css);
            style.appendChild(t);

            if (style.childNodes.length <1)
            {
              //y = style.childNode[0];
              style.removeChild(style.childNode[style.childNodes.length - 1]);
              head.style.childNodes[0].kill();
              head.style.childNodes[i].kill();
              style.removeChild(style.childNode[0]);
              head.style.childNodes[i-1].kill();
              style.removeChild(style.childNode[i]);
              style.removeChild(style.childNode[i-1]);
              head.style.childNodes[style.childNodes.length - 1].kill();
              //console.log(style.childNodes.length);

              i++;
            }


            //head.style.textContent = css;
          }

          head.appendChild(style);

          if (head.childNodes.length > 1)
          {
            //y = style.childNodes[0];
            //head.removeChild(y);
          }
        }

        // variables needed before draw loop

        var i  = .99;
        var spor = -1;
        var ppanx;
        var ppanz;
        var pcamrotx;// = camera.rotation;
        var pcamroty;
        var pcamrotz;
        var pcamposx;
        var pcamposy;
        var pcamposz;
        var lastTouched;
        var wait = 10;
        var stcamrotx = -2.11;
        var stcamroty = .016;
        var stcamrotz = 3.12;
        var stcamposx = -36.83;
        var stcamposy = 10.56;
        var stcamposz = 57.57;

        var stconposx = 1;
        var stconposy = -5.4;
        var stconposz = 50;

        var snapfactor = .1; // between zero and one

        function asym(basis, input)
        {
          return input + ((basis - input) / Math.round(1 / snapfactor));
        }

        // draw loop
        function animate()
        {
          requestAnimationFrame( animate );
          //stats.begin();
          var timer = performance.now();

					// weak attempt at pan limiting
          var panx = 20;
          var panz = 20;
          controls.target.y = -5.4;// * (camera / 40);
          //console.log(camera);

          var secnds = new Date();

          if (pcamrotx != camera.rotation.x || pcamroty != camera.rotation.y || pcamrotz != camera.rotation.z)
          {
            if (pcamposx != camera.position.x || pcamposy != camera.position.y || pcamposz != camera.position.z)
            {
              lastTouched = secnds.getTime();
            }
          }

          var cnposx = controls.target.x + (stconposx - controls.target.x) / (1 / snapfactor);
          var cnposy = controls.target.y + (stconposy - controls.target.y) / (1 / snapfactor);
          var cnposz = controls.target.z + (stconposz - controls.target.z) / (1 / snapfactor);

          if (secnds.getTime() - lastTouched > wait * 1000)
          {
            // fix this
            controls.target.x = stconposx;//cnposx;//controls.target.x + (stconposx - controls.target.x) / (1 / snapfactor);
            controls.target.y = stconposy;//cnposy;//controls.target.y + (stconposy - controls.target.y) / (1 / snapfactor);
            controls.target.z = stconposz;//cnposz;//controls.target.z + (stconposz - controls.target.z) / (1 / snapfactor);

            camera.position.x = stcamposx;//asym(camera.position.x, stcamposx);
            camera.position.y = stcamposy;//asym(camera.position.y, stcamposy);
            camera.position.z = stcamposz;//asym(camera.position.z, stcamposz);
          }

          pcamrotx = camera.rotation.x;
          pcamroty = camera.rotation.y;
          pcamrotz = camera.rotation.z;

          pcamposx = camera.position.x;
          pcamposy = camera.position.y;
          pcamposz = camera.position.z;


          //Camera Pan Limiter
          /*
          if (controls.target.x > panx) {
              controls.target.x = panx;
          }
          if (controls.target.x < -1 * panx) {
              controls.target.x = -1 * panx;
          }
          if (controls.target.z > panz) {
              controls.target.z = panz + 50;
          }
          if (controls.target.z < -1 * panz) {
              controls.target.z = -1 * panz;
          }
          controls.target.y = 0;
          controls.enableDamping = false;
          ppanx = controls.target.x;
          ppanz = controls.target.z - 50;
          //console.log(camera.rotation, pcamrot);
          //console.log(camera);
          */


          var useddots = Array();

          var speed = .0008;
          var scale = .18;
          var pointsFactor = .25;
          var room = "C-101"; // changes with clicks

          curvesToAdd = [];

          // curve adder function(s)
          var curveIndex;
          for (curveIndex = 0; curveIndex < curveArray.length; curveIndex++)
          {
            var curveChar;
            for (curveChar = 0; curveChar < curveArray[curveIndex].name.length; curveChar++)
            {
              if (room[curveChar] != curveArray[curveIndex].name[curveChar] && curveChar != 1 && curveArray[curveIndex].name[curveChar] != 'x')
              {
                break;
              }
              if (curveArray[curveIndex].name[curveChar] == 'x' || curveChar == (curveArray[curveIndex].name.length - 1))
              {
                // append CurvesToAdd
                curvesToAdd.push(curveIndex);
                break;
              }
            }
          }

          // zero to one variable
          if (i >= 1)
          {
            i = 1;
            spor = -1;
          }
          i = (i + (spor * speed));
          if (i <= 0)
          {
            i = 1;
          }

          // make curves invisible
          var blanker;
          for (blanker = 0; blanker < curveArray.length; blanker++)
          {
            curveArray[blanker].visible = false;
          }

          // calculate total needed dots
          var totaluseddots = 0;
          var eye;
          for (eye = 0; eye < curvesToAdd.length; eye++)
          {
            totaluseddots += curveEqArray[curvesToAdd[eye]].points.length * pointsFactor;
            useddots[eye] = curveEqArray[curvesToAdd[eye]].points.length * pointsFactor;
          }

          // make selected curves visible, position and move them along curve
          var dotally = 0;
          var p;
          for (p = 0; p < curvesToAdd.length; p++)
          {
            curveArray[curvesToAdd[p]].visible = true;
            for (q = 0; q < useddots[p]; q++)
            {
              dots[dotally].scale.x = scale * 1.5;
              dots[dotally].scale.y = scale * 1.5;
              dots[dotally].scale.z = scale * 1.5;

              dots[dotally].position.x = curveEqArray[curvesToAdd[p]].getPoint((i + (q / useddots[p])) % 1).x * curveArray[curvesToAdd[p]].scale.x + curveArray[curvesToAdd[p]].position.x;
              dots[dotally].position.y = curveEqArray[curvesToAdd[p]].getPoint((i + (q / useddots[p])) % 1).y * curveArray[curvesToAdd[p]].scale.y + curveArray[curvesToAdd[p]].position.y;
              dots[dotally].position.z = curveEqArray[curvesToAdd[p]].getPoint((i + (q / useddots[p])) % 1).z * curveArray[curvesToAdd[p]].scale.z + curveArray[curvesToAdd[p]].position.z;

              dotally++;
            }
          }

          // THREE functions updatae
          controls.update();
          composer.render();
          mixer.update(clock.getDelta());

          scene.background = new THREE.Color(0xc0d9ff);
          }
        </script>
    </body>
</html>
