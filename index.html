<html>

  <head>

    <title>Clean THREE</title>

    <style>

      body
      {
        margin: 0;
      }

      canvas
      {
        width: 100%;
        height: 100%;
      }

      div
      {
        width: 30vw;
        height: 30vw;
        border: 7px solid blue;
      }

      #canvas
      {
        background-color: #f0f;
        width: 0px;
        height: 0px;
        border: 7px solid blue;
        margin: 100px;
        padding: 20px;
        /*position: static; /* fixed or static */
        top: 100px;
        left: 100px;
      }

      .border
      {
        padding:10px;
        margin:10px;
      }

    </style>

  </head>

  <body>


    <script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/loaders/GLTFLoader.js"></script>
    <script src="js/shaders/CopyShader.js"></script>
    <script src="js/shaders/FXAAShader.js"></script>
    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/postprocessing/OutlinePass.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>
    <script>
    // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277

      // declaring big boy variables
      var container, stats;
      var camera, scene, renderer, controls;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var selectedObjects = [];
      var composer, effectFXAA, outlinePass;
      var group = new THREE.Group();
      var obj3d = new THREE.Object3D();
      var divWidth = 500;//window.innerWidth;//500;
      var divHeight = 500;//window.innerHeight;//500;
      //animation handler
      var mixer, clips;
      var clock = new THREE.Clock(true);

      init();
      animate();

      function init()
      {
        // initialize renderer
        renderer = new THREE.WebGLRenderer();

        // initialize cutout as div
        document.body.appendChild( renderer.domElement );

        // set to cutout size in the future
        var width = divWidth;
        var height = divHeight;

        // enable shadows
        renderer.shadowMap.enabled = true;

        // initialize scene
        scene = new THREE.Scene();

        // initialize and position camera
        camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
        camera.position.set( 0, 0, 8 );

        // initialize and customize controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI/2;
        controls.enablePan = true;
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // add ambient light
        scene.add( new THREE.AmbientLight( 0xaaaaaa, 0.2 ) );

        // add point light
        var light = new THREE.PointLight(0xddffdd, 0.7);
        light.position.set( 5, 5, 5 );
        light.castShadow = true;
        scene.add( light );

        //add the group of all models into the scene
        scene.add( group );

        // add and position model

        var loader = new THREE.GLTFLoader();

        function loadGltf(path, position, modelGroup){

          loader.load( path, function ( gltf )
          {
            console.log(gltf.animations[0]);
            clips = gltf.animations;
            gltf.animations.forEach(function(anim){console.log(anim.name)});
            //for each scene in the array of scene
            gltf.scenes.forEach(function (curScene){
              //adds the objects to a new group
              var sceneGroup = new THREE.Group();
              var sceneLength = curScene.children.length;
              for(var i = 0; i < sceneLength; i++){
                curScene.children.userData = {alreadyUp:false};
                sceneGroup.add(curScene.children[0]);
              }
              sceneGroup.position.copy(position);
              //for each object in the scene
              sceneGroup.traverse( function (child){
                if (child instanceof THREE.Mesh){
                  if (child.geometry.isGeometry){
                    child.geometry.center();
                    child.geometry.computeBoundingSphere();
                    scale = 2 * child.geometry.boundingSphere.radius;
                    child.material = phongMaterial;
                    child.receiveShadow = true;
                    child.castShadow = true;
                  }
                }
              });
              modelGroup.add(sceneGroup);
            });
          });
        }

        loadGltf('models/Nangaku.gltf', new THREE.Vector3(1,1,0), group);

        mixer = new THREE.AnimationMixer();

        // add and position floor
        var floorMaterial = new THREE.MeshLambertMaterial({color: 0xffffff, side: THREE.DoubleSide});
        var floorGeometry = new THREE.PlaneBufferGeometry(200, 200);
        var floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x -= Math.PI * 0.5;
        floorMesh.position.y = 0;
        //scene.add(floorMesh);
        floorMesh.receiveShadow = true;

        // initialize postprocessing
        composer = new THREE.EffectComposer( renderer );
        var renderPass = new THREE.RenderPass( scene, camera );
        composer.addPass( renderPass );
        outlinePass = new THREE.OutlinePass( new THREE.Vector2( divWidth, divHeight ), scene, camera );
        composer.addPass( outlinePass );

        // initialize antialiasing
        effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );

        // initialize event listeners
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mousedown', onTouchMove );
        window.addEventListener( 'touchmove', onTouchMove );



        function playAnimation( rootObject ){
          var loops = 0
          loops++;
          var action = mixer.clipAction( clips[0], rootObject );
          action.paused = false;
          action.clampWhenFinished = true;
          action.setLoop(THREE.LoopOnce, loops);
          if(rootObject.alreadyUp){
            loops++;
            action.setLoop(THREE.LoopOnce, loops);
            action.timeScale = -1;
            action.paused = false;
          }
          else{action.timeScale = 1;}

          rootObject.alreadyUp = !rootObject.alreadyUp;
          //console.log(rootObject.alreadyUp);
          action.play();
        }

        // event triggered functions

        function onTouchMove( event )
        {
          var x, y;
          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( x / divWidth ) * 2 - 1;
          mouse.y = - ( y / divHeight ) * 2 + 1;
          checkIntersection();
        }

        //
        function addSelectedObject( object )
        {
          selectedObjects = [];
          selectedObjects.push( object );
        }

        //
        function checkIntersection()
        {
          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            //gets first selected object
            var selectedObject = intersects[0].object;
            selectedObject.parent.children.forEach(function(child){
              if (child.name.slice(0, child.name.length - 3) == 'floorTwo'){
                playAnimation(child);
              }
            });


            addSelectedObject(selectedObject);

            //add the selected object to list of highlighted objects
            outlinePass.selectedObjects = selectedObject.parent.children;

          }
          else
          {
            outlinePass.selectedObjects = [];
          }
        }

        /*function selectedObjectAnimate(selectedObject){
          selectedObject.parent.children.forEach(function (child){
            if(child.name.slice(0, child.name.length - 3) != 'floorOne'){
              playAnimation(child, 'Roof');
            }
          });
        }*/

        // }

        var width = divWidth;
        var height = divHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize( width, height );
        composer.setSize( width, height );
      }

      // resize the screen correctly
      function onWindowResize()
      {
        var width = divWidth;
        var height = divHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize( width, height );
        composer.setSize( width, height );
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
      }

      // draw loop
      function animate()
      {
        requestAnimationFrame( animate );
        controls.update();
        composer.render();
        mixer.update(clock.getDelta());
      }

    </script>
  </body>
</html>
