<!DOCTYPE html>
<html>
  <title>Nangaku Building</title>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      /*changing asthetics (MERGER)*/
      body {
          font-family: "Raleway", sans-serif;
          font-weight: normal;
          font-style: normal;
      }
      /* side bar itself */
      .sidenav {
          height: 100%;
          width: 0;
          position: fixed;
          z-index: 1;
          top: 0;
          right: 0;
          background-color: rgb(255, 153, 65);
          overflow-x: hidden;
          transition: .75s;
          padding-top: 30px;
      }
      /* title at top */
      g
      {
        font-size: 36px;
        padding: 0px 3px 0px 7px;
        color: #ffffff;
        margin-bottom: 20px;
      }

      /*asthetic rectangle*/
      .rectangle {
        position: absolute;
        left: 10px;
        height: 10px;
        width: 136px;
        align: left;
        background-color: #ffffff;
      }

      /* list of events */
      .sidenav a {
          /* space between (top, right side, bottom, left side )*/
          padding: 20px 5px 0px 10px;
          text-decoration: none;
          font-size: 24px;
          color: #ffffff;
          display: block;
          transition: 0.5s;
          line-height: 1em;
          margin-top: 10px;

      }

      .dropdown-container{
        display:none;
      }

      /* color of text after hover*/
      .sidenav a:hover {
          color: #000000;
      }

      /* close sidebar button */
      .sidenav .closebtn {
          position: absolute;
          top: 0;
          right: 10px;
          font-size: 36px;
          margin-left: 50px;
      }

      p
      /* what opens after clicking on an event */
      {
        font-size: 18px;
        padding-left: 35px;
        padding-right: 3px;
        padding-top: 0px;
        padding-bottom: 0px;
        color: #818181;
      }

      /*text specific for directions */
      .sidenav b {
          padding: 0px 5px 35px 35px;
          text-decoration: bold;
          font-size: 18px;
          color: #818181;
          display: block;
          transition: 0.3s;
      }
      /* color of text after hover*/
      .sidenav b:hover {
          color: #f1f1f1;
      }

      #main {
          transition: margin-left .5s;
          padding: 16px;
      }

      @media screen and (max-height: 450px) {
        .sidenav {padding-top: 15px;}
        .sidenav a {font-size: 18px;}
      }
    </style>
  </head>

<body>

  <div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

  <g> EVENTS </g>

  <div class="rectangle"></div>

  <a class="dropdown-btn"> <div id ="event1"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time1"></p>
    <p id ="location1"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event2"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time2"></p>
    <p id ="location2"></p>
    <b href="#">Directions</b>
  </div>

  <a class="dropdown-btn"> <div id="event3"></div>
    <i class="fa fa-caret-down"></i>
  </a>
  <div class="dropdown-container">
    <p id ="time3"></p>
    <p id ="location3"></p>
    <b href="#">Directions</b>
  </div>

<script>
  //width of sidebar
  function openNav() {
    document.getElementById("mySidenav").style.width = "250px";
    document.getElementById("main").style.marginRight = "250px";
  }
  function closeNav() {
    document.getElementById("mySidenav").style.width = "0";
    document.getElementById("main").style.marginLRight= "0";
  }

  //startClosed();
</script>

<script>
  var dropdown = document.getElementsByClassName("dropdown-btn");
  var i;
  for (i = 0; i < dropdown.length; i++) {
    dropdown[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var dropdownContent = this.nextElementSibling;
      if (dropdownContent.style.display === "none") {
        dropdownContent.style.display = "block";
      } else {
        dropdownContent.style.display = "none";
      }
    });
  }
</script>

<script>

</script>

<script>
  //array for list of events
  var listEvent = ["Landis Aquarium", "Science Fair", "Iolani vs HPA Boys Varsity Soccer"];
  var events = listEvent.length;
  //listing all the events
  for (var i = 0; i < events; i++){
    var firstEvent = "event" + i;
    var secondEvent = "event" + (i + 1);
    var newEvent = firstEvent.replace(firstEvent.toString(),secondEvent.toString());
    document.getElementById(newEvent).innerHTML = listEvent[i];
  }

  //array for list of times that corrospond with events
  var listTime = ["10:10-11:15am", "12:15-1:00pm", "12:15-1:00pm"];
  var times = listTime.length;
  //listing all the times
  for (var j = 0; j < times; j++){
    var firstTime = "time" + j;
    var secondTime = "time" + (j + 1);
    var newTime = firstTime.replace(firstTime.toString(),secondTime.toString());
    document.getElementById(newTime).innerHTML = listTime[j];
  }

  //array for list of locations that corrospond with events and time
  var listLocation = ["Location: N-110", "Location: N-203", "Location: N-105"];
  var locations = listLocation.length;
  //listing all the locations
  for (var j = 0; j < locations; j++){
    var firstLocation = "location" + j;
    var secondLocation = "location" + (j + 1);
    var newLocation = firstLocation.replace(firstLocation.toString(),secondLocation.toString());
    document.getElementById(newLocation).innerHTML = listLocation[j];
  }
</script>

  <script src="js/three.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  <script src="js/loaders/GLTFLoader.js"></script>
  <script src="js/shaders/CopyShader.js"></script>
  <script src="js/shaders/FXAAShader.js"></script>
  <script src="js/postprocessing/EffectComposer.js"></script>
  <script src="js/postprocessing/RenderPass.js"></script>
  <script src="js/postprocessing/ShaderPass.js"></script>
  <script src="js/postprocessing/OutlinePass.js"></script>
  <script src="js/libs/stats.min.js"></script>
  <script src='js/libs/dat.gui.min.js'></script>

  <div id = 'canvas'>
    <script>
    // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277


    <script>
    function openNav() {
        document.getElementById("mySidenav").style.width = "250px";
        document.getElementById("main").style.marginRight = "250px";
    }
    function closeNav() {
        document.getElementById("mySidenav").style.width = "0";
        document.getElementById("main").style.marginLRight= "0";
    }
    </script>

    <script>

    // create dropdown within sidebar and add listener for toggle
    var dropdown = document.getElementsByClassName("dropdown-btn");
    var i;
    for (i = 0; i < dropdown.length; i++) {
      dropdown[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var dropdownContent = this.nextElementSibling;
        if (dropdownContent.style.display === "block") {
          dropdownContent.style.display = "none";
        } else {
          dropdownContent.style.display = "block";
        }
      });
    }

    </script>

      <script src="js/three.js"></script>
      <script src="js/controls/OrbitControls.js"></script>
      <script src="js/loaders/GLTFLoader.js"></script>
      <script src="js/shaders/CopyShader.js"></script>
      <script src="js/shaders/FXAAShader.js"></script>
      <script src="js/postprocessing/EffectComposer.js"></script>
      <script src="js/postprocessing/RenderPass.js"></script>
      <script src="js/postprocessing/ShaderPass.js"></script>
      <script src="js/postprocessing/OutlinePass.js"></script>
      <script src="js/libs/stats.min.js"></script>
      <script src='js/libs/dat.gui.min.js'></script>
      <script src='js/NameList.js'></script>
      <div id = 'canvas'>
        <script>
        // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277

        // heap clears frequently, nodes do not

        // use this function to interact with JavaScript from sidebar interaction
        const changeText = () => {}

      // declaring big boy variables
      var t;
      var container, stats;
      var camera, scene, renderer, controls;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var selectedObjects = [];
      var composer, effectFXAA, outlinePass;
      var group = new THREE.Group();
      var obj3d = new THREE.Object3D();
      var clips;
      var mixer = new THREE.AnimationMixer();
      var clock = new THREE.Clock(true);
      var divWidth = window.innerWidth * 3 / 4;// / 2;//500;
      var divHeight = window.innerHeight * 5 / 7// / 2;//500;
      var xd = 1;
      var yd = 1;
      var xx = 0;
      var yy = 0;
      init();
      onWindowResize();
      animate();

      function init()
      {
        //startClosed();

        container = document.getElementById( 'canvas' );
        document.body.appendChild( container );

        renderer = new THREE.WebGLRenderer({ alpha: true });
        container.appendChild( renderer.domElement );


        // set to cutout size in the future
        var width = divWidth;
        var height = divHeight;

        // enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;

        // initialize scene
        scene = new THREE.Scene();


        // initialize and position camera
         camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
        camera.position.set( 0, 0, 8 );

        // initialize and customize controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 2;
        controls.maxDistance = 5;
        controls.maxPolarAngle = 11*Math.PI/24;
        controls.enablePan = true;
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.target.x =  1;
        controls.enableZoom = true;

        // add ambient light
        scene.add( new THREE.AmbientLight( 0xffffff, .4 ) );

        // add point light
      /*  var light = new THREE.SpotLight( 0xffffff );
        //var light = new //THREE.HemisphereLight(0xffffff, 0x808020, 1);//PointLight(0xffffff);
        scene.add( light );
        light.position.set( -800, 800, 800 );
        light.rotation.set( -Math.PI / 4, 0, -Math.PI / 4 );


        light.intensity = 1.2;
        light.angle = Math.PI / 2;
        //light.position.y = 200;
        light.penumbra = 100;
        //light.rotation.z = -400;
        //light.position.x = -100;

        //light.shadow.mapSize.width = 512;  // default
        //light.shadow.mapSize.height = 512; // default
        light.shadow.camera.near = 0.5;       // default
        light.shadow.camera.far = 500;


        light.castShadow = true;
<<<<<<< Updated upstream
<<<<<<< HEAD
        var smapsize = 2048;
        light.shadow.mapSize.width = smapsize;
        light.shadow.mapSize.height = smapsize;

        var light = new THREE.DirectionalLight(0xffffff,1);
        light.position.set(50, 500, 22);
        light.target.position.set(300, 400, 200);
        var light = new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0, 500, 200);
        light.target.position.set(0, 0, 0);
        light.shadow.mapSize.width = 1024*4;
        light.shadow.mapSize.height = 1024*4;
        light.castShadow = true;

        light.shadow.camera.near = 0;
        light.shadow.camera.far = 4000;
        light.shadow.camera.fov = 90;
        scene.add(light);


        //add the group of all models into the scene
        scene.add( group );

        /*
        *Model Loaders
        */

        /*
        *Main function to load in the school model.
        *path takes a string of the file path of the model (GLTF format)
        *position takes a Vector3 and sets the the model centered to that position
        *modelGroup takes a Group and makes it the top of the tree
        *Each mesh in the model is added to a group based on the scene that it is in
        *each scene is then added to modelGroup
        */
        var loader = new THREE.GLTFLoader();

        function loadCampus(path, position, modelGroup){
          loader.load( path, function ( gltf )
          {
            clips = gltf.animations;
            /*
            *Each Scene is named a 1 letter code for what building it represents
            *E.G. Weinberg is W, Nangaku is N
            */
            gltf.scenes.forEach(function (curScene){
              var sceneGroup = new THREE.Group();
              sceneGroup.name = curScene.name;
              var sceneLength = curScene.children.length;

              /*
              *Each mesh has a prefix indicating the building it is a part of and the floor
              *e.g. N2 means Nangaku second floor
              *Each room is named after its room number e.g. N203 or N204
              *Each non room mesh is named with its prefix and followed by part
              */
              for(var i = 0; i < sceneLength; i++){

                sceneGroup.add(curScene.children[0]);
              }
              sceneGroup.children.forEach( function (child){
                if (child instanceof THREE.Mesh){
                  child.receiveShadow = true;
                  child.castShadow = true;
                  //tests if the mesh is a room or just an aesthetic part
                  if(child.name.slice(3, -3) == 'part'){
                    //Adds custom object containing if it is a selectable room and if it is already animated and the name(s) of the room
                    child.userData = {alreadyUp:false, room:false};
                  }

                  else{
                    //Accesses a list of names and adds each one to the model
                    child.userData = {alreadyUp:false, room:true, names:findNames(child.name)};
                  }
                }
              });
              modelGroup.add(sceneGroup);
            });
          });
          modelGroup.position.copy(position);
        }

        // add Nangaku model
        loadCampus('models/Nangaku6.gltf', new THREE.Vector3(1,0,-1), group);

        // add and position floor

        var floorMaterial = new THREE.MeshPhongMaterial({color: 0x6d6d6d});
        var floorGeometry = new THREE.PlaneBufferGeometry(100, 100);

        var floorMaterial = new THREE.MeshLambertMaterial({color: 0xffffff, side: THREE.DoubleSide});
        var floorGeometry = new THREE.PlaneBufferGeometry(20, 20);

        var floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x -= Math.PI * 0.5;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        floorMesh.castShadow = true;
        scene.add(floorMesh);



        // initialize postprocessing
        composer = new THREE.EffectComposer( renderer );
        var renderPass = new THREE.RenderPass( scene, camera );
        composer.addPass( renderPass );
        outlinePass = new THREE.OutlinePass( new THREE.Vector2( divWidth, divHeight ), scene, camera );
        composer.addPass( outlinePass );

        // initialize antialiasing
        effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );

        // initialize event listeners
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mouseup', onTouchMove );
        window.addEventListener( 'touchend', onTouchMove );
        window.addEventListener( 'touchstart', onmesh);
        window.addEventListener( 'mousedown', onmesh);
        window.addEventListener( 'mousemove', stopstart);

        // variables for listener functions
        var clicked = true;
        var started = false;
        var lfclick = true;
        var prevobj = null;

        //function returns a room when given a name (e.g. n203, w315, Library)
        function findRoom(roomName){
          group.forEach(function(building){
            building.forEach(function(room){
              room.names.forEach(function(name){
                if(name == roomName){
                  return room;
                }
              })
            });
          });
          return null;
        }

        /*
        * Animation Functions
        */

        //given a name and am object plays an animation
        function playAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.play();
        }

        function stopAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.stop();
        }

        //plays animation on a object forwards or backwards stopping on last frame
        function playFloorAnimation( rootObject, isUp, clipName ){

          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );

          action.clampWhenFinished = true;
          action.setLoop(THREE.LoopOnce);

          if(isUp){
            action.timeScale = -1;
          }

          else{action.timeScale = 1;}
          rootObject.alreadyUp = !rootObject.alreadyUp;
          action.play();
          action.paused = false;
        }

        function lowerFloor(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.timeScale = -1;
          action.clampWhenFinished = true;
          action.paused = false;
          action.play();
          rootObject.alreadyUp =  false;
          action.setLoop(THREE.LoopOnce);
        }

        function raiseFloor(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.timeScale = 1;
          rootObject.alreadyUp =  true;
          action.setLoop(THREE.LoopOnce);
          action.clampWhenFinished = true;
          action.play();
          action.paused = false;
        }

        /*
        *Animates all floors in the building Group
        *putting 'pingPong' for animation mode toggles the animation Up and down
        * 'lower' only lowers the floors if they are up
        *'raise' raises the floors if they are dowb.
        */

        function animateFloors(selectedRoom, animationMode){
          if(animationMode  == 'PingPong'){
            selectedRoom.parent.children.forEach(function(child){
              //plays animations by the name of the floors, each floor's suffix has a matching animation
              if (THREE.AnimationClip.findByName(clips,child.name.slice(0, -3)) != null){
                playFloorAnimation(child, child.alreadyUp, child.name.slice(0, -3));
              }
              else{child.alreadyUp = !child.alreadyUp;}
            });
          }

          else if(animationMode == 'Lower'){
            selectedRoom.parent.children.forEach(function(child){
              //plays animations by the name of the floors, each floor's suffix has a matching animation
              if (THREE.AnimationClip.findByName(clips,child.name.slice(0, -3)) != null){
                lowerFloor(child, child.name.slice(0, -3));
              }
              else {child.alreadyUp =  false}
            });
          }

          else if (animationMode == 'Raise') {
            selectedRoom.parent.children.forEach(function(child){
              //plays animations by the name of the floors, each floor's suffix has a matching animation e.g. Nangaku second floor is N2
              if (THREE.AnimationClip.findByName(clips,child.name.slice(0, -3)) != null){
                raiseFloor(child, child.name.slice(0, -3));
              }
              else {child.alreadyUp =  true}
            });
          }
          else {console.log("Invalid Input, use pingPong, raise, or lower")}
        }

        /////////////////////////////////
        //  event triggered functions  //
        /////////////////////////////////

        function stopstart (event)
        {
          if (!lfclick)
          {
            controls.enableRotate = false;
            controls.enablePan = true;
            console.log("a");
          }
          else
          {
            controls.enableRotate = true;
            //controls.enablePan = false;
            //console.log("b");
          }
        }

        function onmesh (event)
        {
          var x, y;

          if (event.button == 2)
          {
            lfclick = false;
          }
          else
          {
            lfclick = true;
          }

          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;

          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            started = true;
          }
          else
          {
            started = false;
          }

          // put opennav where

        }

        //

        function onTouchMove( event )
        {
          var x, y;
          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;
          checkIntersection();
        }

        //
        function addSelectedObject( object )
        {
          selectedObjects = [];
          selectedObjects.push( object );
        }

        //
        function checkIntersection()
        {
          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            outlinePass.selectedObjects = [];

            var selectedObject = intersects[ 0 ].object;
            animateFloors(selectedObject, 'PingPong');

            addSelectedObject( selectedObject );
            if (clicked && started || prevobj != selectedObject)
            {
              outlinePass.selectedObjects = selectedObjects;
              openNav();
            }
            else
            {
              outlinePass.selectedObjects = [];
              closeNav();
            }
            clicked = !clicked;
          }
          else
          {
            if (!started)
            {
              outlinePass.selectedObjects = [];
            }
          }
          prevobj = selectedObject;
        }

        var width = divWidth;
        var height = divHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize( width, height );
        composer.setSize( width, height );
        renderer.domElement.style.width = width + 'px';
        renderer.domElement.style.height = height + 'px';
      }

          // resize the screen correctly
          var i = 0;
          function onWindowResize()
          {
            divWidth = window.innerWidth;// / 2;
            divHeight = window.innerHeight; // 2;
            var width = divWidth;
            var height = divHeight;
            var w2 = 0;//200/7;//= xx;
            var h2 = 0;//= yy;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
            composer.setSize( width, height );
            renderer.domElement.style.width = width + 'px';
            renderer.domElement.style.height = height + 'px';
            //renderer.domElement.style.offsetLeft = w2 + 'px';
            //renderer.domElement.style.offsetTop = h2 + 'px';
            effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );


            var css = '#canvas {background-color: #f0f; margin-left: ' + w2.toString() + 'vw; width: 0px; height: 0px; padding: 0px; margin-top: ' + h2.toString() + 'vw; position: static;}',
            head = document.head || document.getElementsByTagName('head')[0],
            style = document.createElement('style');

            var y;


            style.type = 'text/css';
            if (style.styleSheet)
            {
              // This is required for IE8 and below.
              style.styleSheet.cssText = css;
            }
            else
            {
              t = document.createTextNode(css);
              style.appendChild(t);

              if (style.childNodes.length <1)
              {
                //y = style.childNode[0];
                style.removeChild(style.childNode[style.childNodes.length - 1]);
                head.style.childNodes[0].kill();
                head.style.childNodes[i].kill();
                style.removeChild(style.childNode[0]);
                head.style.childNodes[i-1].kill();
                style.removeChild(style.childNode[i]);
                style.removeChild(style.childNode[i-1]);
                head.style.childNodes[style.childNodes.length - 1].kill();
                //console.log(style.childNodes.length);

                i++;
              }

              console.log(style.childNodes.length);

              //head.style.textContent = css;
            }

            head.appendChild(style);

            if (head.childNodes.length > 1)
            {
              //y = style.childNodes[0];
              //head.removeChild(y);
            }
          }

          // variables needed before draw loop
          var panx = 1;
          var panz = 1;

          // draw loop
          function animate()
          {

            requestAnimationFrame( animate );
            //stats.begin();
            var timer = performance.now();

            if (controls.target.x > panx) {
                controls.target.x = panx;
            }

            if (controls.target.x < -1 * panx) {
                controls.target.x = -1 * panx;
            }
            if (controls.target.z > panz) {
                controls.target.z = panz;
            }
            if (controls.target.z < -1 * panz) {
                controls.target.z = -1 * panz;
            }
            controls.target.y = 0;

            controls.update();
            composer.render();
            //stats.end();
            mixer.update(clock.getDelta());
          }

        </script>

    </body>

</html>
