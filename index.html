<html>

  <head>

    <title>Clean THREE</title>

    <style>

      body
      {
        margin: 0;
      }

      canvas
      {
        width: 100%;
        height: 100%;
      }

      div
      {
        width: 0px;
        height: 0px;

        margin-left: 0px;
      }

      #canvas
      {
        background-color: #f0f;
        width: 0px;
        height: 0px;
        padding: 0px;
        position: static; /* fixed or static */
      }

    </style>

  </head>

  <body>


    <script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>
    <script src="js/shaders/CopyShader.js"></script>
    <script src="js/shaders/FXAAShader.js"></script>
    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/postprocessing/OutlinePass.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>

    <div id = 'canvas'>
      <script>
      // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277

        // declaring big boy variables
        var container, stats;
        var camera, scene, renderer, controls;
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var selectedObjects = [];
        var composer, effectFXAA, outlinePass;
        var group = new THREE.Group();
        var obj3d = new THREE.Object3D();
        var divWidth = window.innerWidth / 2;//500;
        var divHeight = window.innerHeight / 2;//500;

        var xd = 1;
        var yd = 1;
        var xx = 0;
        var yy = 0;


        init();
        onWindowResize();
        animate();

        function init()
        {
          container = document.getElementById( 'canvas' );
          document.body.appendChild( container );

          renderer = new THREE.WebGLRenderer();
          //renderer.setSize( 200, 200 );
          container.appendChild( renderer.domElement );
          /*
          // initialize renderer
          renderer = new THREE.WebGLRenderer();
          renderer.serSize(divWidth, divHeight);
          // initialize cutout as div
          container = document.getElementById( 'canvas' );
          document.body.appendChild( container );
          document.body.appendChild( renderer.domElement );
          container.appendChild( renderer.domElement );
          */

          // set to cutout size in the future
          var width = divWidth;
          var height = divHeight;

          // enable shadows
          renderer.shadowMap.enabled = true;

          // initialize scene
          scene = new THREE.Scene();

          // initialize and position camera
          camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
          camera.position.set( 0, 0, 8 );

          // initialize and customize controls
          controls = new THREE.OrbitControls( camera, renderer.domElement );
          controls.minDistance = 5;
          controls.maxDistance = 20;
          controls.maxPolarAngle = Math.PI/2;
          controls.enablePan = true;
          controls.enableDamping = true;
          controls.dampingFactor = 0.25;

          // add ambient light
          scene.add( new THREE.AmbientLight( 0xaaaaaa, 0.2 ) );

          // add point light
          var light = new THREE.PointLight(0xddffdd, 0.7);
          light.position.set( 5, 5, 5 );
          light.castShadow = true;
          scene.add( light );

          // idk wtf this does
          scene.add( group );

          // add and position model
          var loader = new THREE.OBJLoader();
          loader.load( 'models/slls.obj', function ( mesh )
          {
            mesh.position.set( 0, - 1.5, 0);
            mesh.rotation.set( 0, - Math.PI / 2, 0 );
            mesh.scale.set( 0.5, 0.5, 0.5 );
            mesh.traverse( function (child)
            {
              if (child instanceof THREE.Mesh)
              {
                if (child.geometry.isGeometry)
                {
                  child.geometry.center();
                  child.geometry.computeBoundingSphere();
                  scale = 2 * child.geometry.boundingSphere.radius;
                  var phongMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, specular: 0x111111, shininess: 5 });
                  child.material = phongMaterial;
                  child.receiveShadow = true;
                  child.castShadow = true;
                }
              }
            });
            group.add(mesh);
            //obj3d.add( object );
          });

          // add and position floor
          var floorMaterial = new THREE.MeshLambertMaterial({color: 0xffffff, side: THREE.DoubleSide});
          var floorGeometry = new THREE.PlaneBufferGeometry(200, 200);
          var floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
          floorMesh.rotation.x -= Math.PI * 0.5;
          floorMesh.position.y = 0;
          //scene.add(floorMesh);
          floorMesh.receiveShadow = true;

          // initialize stats
          stats = new Stats();
          container.appendChild( stats.dom );

          // initialize postprocessing
          composer = new THREE.EffectComposer( renderer );
          var renderPass = new THREE.RenderPass( scene, camera );
          composer.addPass( renderPass );
          outlinePass = new THREE.OutlinePass( new THREE.Vector2( divWidth, divHeight ), scene, camera );
          composer.addPass( outlinePass );

          // initialize antialiasing
          effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
          effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
          effectFXAA.renderToScreen = true;
          composer.addPass( effectFXAA );

          // initialize event listeners
          window.addEventListener( 'resize', onWindowResize, false );
          window.addEventListener( 'mouseup', onTouchMove );
          window.addEventListener( 'touchend', onTouchMove );
          window.addEventListener( 'touchstart', onmesh);
          window.addEventListener( 'mousedown', onmesh);

          // event triggered functions
          // {

          var clicked = true;
          var started = false;

          function onmesh (event)
          {
            var x, y;
            if ( event.changedTouches )
            {
              x = event.changedTouches[ 0 ].pageX;
              y = event.changedTouches[ 0 ].pageY;
            }
            else
            {
              x = event.clientX;
              y = event.clientY;
            }
            mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;

            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( [ group ], true );
            if ( intersects.length > 0 )
            {
              started = true;
            }
            else
            {
              started = false;
            }
          }

          //
          function onTouchMove( event )
          {
            var x, y;
            if ( event.changedTouches )
            {
              x = event.changedTouches[ 0 ].pageX;
              y = event.changedTouches[ 0 ].pageY;
            }
            else
            {
              x = event.clientX;
              y = event.clientY;
            }
            mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;
            checkIntersection();
          }

          //
          function addSelectedObject( object )
          {
            selectedObjects = [];
            selectedObjects.push( object );
          }

          //
          function checkIntersection()
          {
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( [ group ], true );
            if ( intersects.length > 0 )
            {
              var selectedObject = intersects[ 0 ].object;
              //camera.position.copy(selectedObject.position);
              //controls.target = selectedObject;
              addSelectedObject( selectedObject );
              if (clicked && started)
              {
                outlinePass.selectedObjects = selectedObjects;
              }
              else
              {
                outlinePass.selectedObjects = [];
              }
              clicked = !clicked;
            }
            else
            {
              if (!started)
              {
                outlinePass.selectedObjects = [];
              }
            }
          }

          // }

          var width = divWidth;
          var height = divHeight;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize( width, height );
          composer.setSize( width, height );
        }

        // resize the screen correctly
        function onWindowResize()
        {
          divWidth = window.innerWidth / 2;
          divHeight = window.innerHeight / 2;
          var width = divWidth;
          var height = divHeight;
          var w2 = xx
          var h2 = yy;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize( width, height );
          composer.setSize( width, height );
          effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );

          var css = '#canvas {background-color: #f0f; margin-left: ' + w2.toString() + 'px; width: 0px; height: 0px; padding: 0px; margin-top: ' + h2.toString() + 'px; position: static;}',
          head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');

          style.type = 'text/css';
          if (style.styleSheet)
          {
            // This is required for IE8 and below.
            style.styleSheet.cssText = css;
          }
          else
          {
            style.appendChild(document.createTextNode(css));
          }

          head.appendChild(style);
        }

        // draw loop

        function animate()
        {
          requestAnimationFrame( animate );
          stats.begin();
          var timer = performance.now();
          controls.update();
          composer.render();
          stats.end();
          xx += xd * (divWidth / 32);
          yy += xd * (divHeight / 32);
          if (xx > divWidth )
          {
            xd = -1;
          }
          if (xx < 0)
          {
            xd = 1;
          }

          if (yy > divHeight)
          {
            yd = -1;
          }
          if (yy < 0)
          {
            yd = 1;
          }

          onWindowResize();
        }

      </script>
    </div>
  </body>
</html>
