<!DOCTYPE html>
<html>
    <title>Nangaku Building</title>
      <head>
      <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
        body {
            font-family: "Gill Sans", sans-serif;
        }

        .sidenav {
            height: 100%;
            width: 0;
            position: fixed;
            z-index: 1;
            top: 0;
            right: 0;
            background-color: #111;
            overflow-x: hidden;
            transition: 0.5s;
            padding-top: 60px;
        }

        .sidenav a {
            padding: 4px 10px 4px 10px;
            text-decoration: none;
            font-size: 25px;
            color: #818181;
            display: block;
            transition: 0.3s;
        }

        .dropdown-container{
          display:none;
        }

        .sidenav a:hover {
            color: #f1f1f1;
        }

        .sidenav .closebtn {
            position: absolute;
            top: 0;
            right: 10px;
            font-size: 36px;
            margin-left: 50px;
        }

        p
        {
          font-size: 18px;
          padding-left: 10px;
          padding-right: 3px;
          padding-top: 0px;
          padding-bottom: 0px;
          color: #818181;
        }

        #main {
            transition: margin-left .5s;
            padding: 16px;
        }

        @media screen and (max-height: 450px) {
          .sidenav {padding-top: 15px;}
          .sidenav a {font-size: 18px;}
        }
        </style>
      </head>
    <body>

      <div id="mySidenav" class="sidenav">
      <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

      <a class="dropdown-btn">Garrett's Amazing 10/10 English 9 Presentation
        <i class="fa fa-caret-down"></i>
      </a>

      <div class="dropdown-container">
        <p>10:10-11:15am</p>
        <p>Location: N-110</p>
        <a href="#">Directions</a>
    </div>
        <a class="dropdown-btn">Chinese Club Lunch
          <i class="fa fa-caret-down"></i>
        </a>

        <div class="dropdown-container">
          <p>12:15-1:00pm</p>
          <p>Location: N-203</p>
          <a href="#">Directions</a>
    </div>
    <a class="dropdown-btn">Keables' Scholar Discussion
      <i class="fa fa-caret-down"></i>
    </a>

    <div class="dropdown-container">
      <p>12:15-1:00pm</p>
      <p>Location: N-105</p>
      <a href="#">Directions</a>
    </div>

      <script src="js/three.js"></script>
      <script src="js/curve.js"></script>
      <script src="js/controls/OrbitControls.js"></script>
      <script src="js/loaders/GLTFLoader.js"></script>
      <script src="js/shaders/CopyShader.js"></script>
      <script src="js/shaders/FXAAShader.js"></script>
      <script src="js/postprocessing/EffectComposer.js"></script>
      <script src="js/postprocessing/RenderPass.js"></script>
      <script src="js/postprocessing/ShaderPass.js"></script>
      <script src="js/postprocessing/OutlinePass.js"></script>
      <script src="js/libs/stats.min.js"></script>
      <script src='js/libs/dat.gui.min.js'></script>
      <script src="js/loaders/OBJLoader.js"></script>

      <div id = 'canvas'>
        <script>
        // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277

        // heap clears frequently, nodes do not

        function openNav() {
            document.getElementById("mySidenav").style.width = "250px";
        }
        function closeNav() {
            document.getElementById("mySidenav").style.width = "0";
        }

        // create dropdown within sidebar and add listener for toggle
        var dropdown = document.getElementsByClassName("dropdown-btn");
        var i;
        for (i = 0; i < dropdown.length; i++) {
          dropdown[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var dropdownContent = this.nextElementSibling;
            if (dropdownContent.style.display === "block") {
              dropdownContent.style.display = "none";
            } else {
              dropdownContent.style.display = "block";
            }
          });
        }

        // use this function to interact with JavaScript from sidebar interaction
        const changeText = () => {

        }

        // declaring big boy variables
        var t;
        var container, stats;
        var camera, scene, renderer, controls;
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var selectedObjects = [];
        var composer, effectFXAA, outlinePass;
        var group = new THREE.Group();
        var obj3d = new THREE.Object3D();
        var clips;
        var mixer = new THREE.AnimationMixer();
        var clock = new THREE.Clock(true);
        var divWidth = window.innerWidth;
        var divHeight = window.innerHeight;
        var objloader = new THREE.OBJLoader();

        var dots = new Array();
        var radius = .2;
        var convtxs = new Float32Array();
        var dotlength;
        var linee;

        var geometr = new THREE.BoxGeometry( radius, radius, radius);
        var materia = new THREE.MeshLambertMaterial( {color: 0xff0000} );
        var spher = new THREE.Mesh( geometr, materia );

        var nucurve;
        var curveptarray = Array();

        var ie;
        var curvee = new THREE.CatmullRomCurve3();
        var pieces = 4;

        var curveMeshArray = Array();
        var curveEqArray = Array();

        var curveCount = 2;

        var matt = new THREE.LineBasicMaterial( { color : 0x00ff00, linecap: 'square', linejoin: 'square', linewidth: 5 } );

        function dot (u)
        {
          var geometr = new THREE.BufferGeometry();
          var ohold;
          objloader.load(
          // resource URL
          'models/arrow.obj',
          // called when resource is loaded
          function ( object ) {

            ohold = object.children[0].geometry;

            var materia = new THREE.MeshBasicMaterial( {color: 0xff0000} );
            var lxl;
            for (lxl = 0; lxl < u; lxl++)
            {
              dots[lxl] = new THREE.Mesh( ohold, materia );

              scene.add(dots[lxl]);

              console.log(lxl, dots[lxl]);
              //scene.add(dots[lxl]);
              dotlength = dots.length;
            }
            console.log(dots.length);

          } );

          console.log(dots.length, "asdf");
        }


        function comppts (q, arr, index)
        {
          var holda = new THREE.CatmullRomCurve3();
          for (ie = 0; ie < (q / 3) - 1; ie++)
          {
            if (ie % pieces == 0)
            {
              curveptarray[ie/pieces] = new THREE.Vector3(arr[ie * 3], arr[ie * 3 + 1], arr[ie * 3 + 2]);
            }
          }
          holda.points = curveptarray;
          curveEqArray[index] = holda;
        }

        function spSetup(file, id, stScale, yScale, buildingLink, index)
        {
          objloader.load(
          // resource URL
          file,
          // called when resource is loaded
          function ( object ) {
            nucurve = new THREE.Line(object, matt);
            comppts(object.children[0].geometry.attributes.position.array.length, object.children[0].geometry.attributes.position.array, index);
            var toobg = new THREE.TubeBufferGeometry( curvee, 100, .03, 4, false );
            var toobm = new THREE.MeshBasicMaterial( { color: 0xff0000} );
            curveMeshArray[index] = new THREE.Mesh( toobg, toobm );
            console.log("agu");
            console.log(curveMeshArray[curveMeshArray.length])
            curveMeshArray[id].scale.x = stScale;
            curveMeshArray[id].scale.y = stScale;
            curveMeshArray[id].scale.y = stScale;
            scene.add( curveMeshArray[id] );
        	});
          console.log("agu");
        }

        function init2 ()
        {
          spSetup('models/sample_curve4.obj', 0, 2, 1, 'sullivan', 1);
        }

        init();
        onWindowResize();
        animate();

        function init()
        {
          // create container
          container = document.getElementById( 'canvas' );
          document.body.appendChild( container );

          // create renderer
          renderer = new THREE.WebGLRenderer({ alpha: true });
          container.appendChild( renderer.domElement );

          // set to cutout size in the future
          var width = divWidth;
          var height = divHeight;

          // enable shadows
          renderer.shadowMap.enabled = true;
          //renderer.shadowMap.type = THREE.BasicShadowMap;

          // initialize scene
          scene = new THREE.Scene();

          // initialize and position camera
          camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
          //var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, -1000, 1000 );
          camera.position.set( 0, 0, 8 );

          // initialize and customize controls
          controls = new THREE.OrbitControls( camera, renderer.domElement );
          //controls.minDistance = 2;
          //controls.maxDistance = 5;
          //controls.maxPolarAngle = 11*Math.PI/24;
          controls.enablePan = true;
          controls.enableDamping = true;
          controls.dampingFactor = 0.25;
          controls.target.x =  1;
          controls.enableZoom = true;

          // add ambient light
          scene.add( new THREE.AmbientLight( 0xffffff, .4 ) );
          var light = new THREE.DirectionalLight(0xffffff,.3);
          light.position.set(0, 500, 200);
          light.target.position.set(0, 0, 0);
          light.shadow.mapSize.width = 1024*4;
          light.shadow.mapSize.height = 1024*4;
          light.castShadow = true;

          light.shadow.camera.near = 0;
          light.shadow.camera.far = 4000;
          light.shadow.camera.fov = 90;
          scene.add(light);      var light = new THREE.DirectionalLight(0xffffff,.3);
          light.position.set(0, 500, 200);
          light.target.position.set(0, 0, 0);
          light.shadow.mapSize.width = 1024*4;
          light.shadow.mapSize.height = 1024*4;
          light.castShadow = true;

          light.shadow.camera.near = 0;
          light.shadow.camera.far = 4000;
          light.shadow.camera.fov = 90;
          scene.add(light);

          //add the group for all models to join
          scene.add( group );

          // initialize gltf loader
          var loader = new THREE.GLTFLoader();

          // define function that loads in models (gltf)
          function loadGltf(path, position, modelGroup){
            loader.load( path, function ( gltf )
            {
              clips = gltf.animations;
              gltf.animations.forEach(function(anim){console.log(anim.name)});
              //for each scene in the array of scene
              gltf.scenes.forEach(function (curScene){
                //adds the objects to a new group
                var sceneGroup = new THREE.Group();
                var sceneLength = curScene.children.length;
                for(var i = 0; i < sceneLength; i++){
                  curScene.children.userData = {alreadyUp:false};
                  sceneGroup.add(curScene.children[0]);
                }
                sceneGroup.position.copy(position);
                //for each object in the scene
                sceneGroup.children.forEach( function (child){
                  if (child instanceof THREE.Mesh){
                    if (child.geometry.isBufferGeometry){
                      console.log(child.name);
                      if(child.name == "Cylinder001"){
                        child.visible = false;
                      }
                      child.receiveShadow = true;
                      child.castShadow = true;
                    }
                  }
                });
                modelGroup.add(sceneGroup);
              });
            });
          }

          // Add in red line
          //ar linee;
          objloader.load(
        	// resource URL
        	'models/sample_curves.obj',
        	// called when resource is loaded
        	function ( object ) {
            nucurve = new THREE.Line(object, matt);
            comppts(object.children[0].geometry.attributes.position.array.length, object.children[0].geometry.attributes.position.array, 0);
            var toobg = new THREE.TubeBufferGeometry( curvee, 100, .03, 4, false );
            var toobm = new THREE.MeshBasicMaterial( { color: 0xff0000} );
            linee = new THREE.Mesh( toobg, toobm );
            scene.add( linee );
        	},
        	// called when loading is in progresses
        	function ( xhr ) {

        		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

        	},
        	// called when loading has errors
        	function ( error ) {

        		console.log( 'An error happened' );

        	}
          );

          // add Nangaku model
          loadGltf('models/Nangaku6.gltf', new THREE.Vector3(2,0,-2), group);

          // add and position floor
          var floorMaterial = new THREE.MeshPhongMaterial({color: 0x6d6d6d});
          var floorGeometry = new THREE.PlaneBufferGeometry(100, 100);
          var floorMaterial = new THREE.MeshLambertMaterial({color: 0xccffcc});
          var floorGeometry = new THREE.PlaneBufferGeometry(20, 20);
          var floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
          floorMesh.rotation.x -= Math.PI * 0.5;
          floorMesh.position.y = -4;
          floorMesh.receiveShadow = true;
          floorMesh.castShadow = true;
          scene.add(floorMesh);

          // initialize postprocessing
          composer = new THREE.EffectComposer( renderer );
          var renderPass = new THREE.RenderPass( scene, camera );
          composer.addPass( renderPass );
          outlinePass = new THREE.OutlinePass( new THREE.Vector2( divWidth, divHeight ), scene, camera );
          composer.addPass( outlinePass );

          // initialize antialiasing
          effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
          effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
          effectFXAA.renderToScreen = true;
          composer.addPass( effectFXAA );

          dot(20);

          var lx;
          for (lx = 0; lx < dots.length; lx++)
          {
            console.log(dots[lx], lx);
            scene.add(dots[lx]);
            console.log("WHAT HAPPEN");
          }

          init2();

        }

        /////////////////////////////////
        //     animation functions     //
        /////////////////////////////////

        function playAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, 'Arrow'), rootObject );
          action.play();
        }

        function stopAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, 'Arrow'), rootObject );
          action.stop();
        }

        //plays animation on a object forwards or backwards stopping on last frame
        function playFloorAnimation( rootObject, isUp, clipName ){
          var loops = 0;
          loops++;
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.paused = false;
          action.clampWhenFinished = true;
          action.setLoop(THREE.LoopOnce, loops);
          if(isUp){
            loops++;
            action.setLoop(THREE.LoopOnce, loops);
            action.timeScale = -1;
            action.paused = false;
          }
          else{action.timeScale = 1;}
          rootObject.alreadyUp = !rootObject.alreadyUp;
          action.play();
        }

        //takes a group of a building and applies an animation to each floor
        //isUp determines direaction of animation, true is forward, false is reverse, putting the child.alreadyUp makes it ping pong
        function animateFloors(buildingGroup, isUp){
          buildingGroup.children.forEach(function(child){

            //plays animations by the name of the floors, each floor is named after its animation
            if (THREE.AnimationClip.findByName(clips,child.name.slice(0, (child.name.length - 3))) != null){
              playFloorAnimation(child, isUp, child.name.slice(0, (child.name.length - 3)));
              console.log("working");
            }
            else{child.alreadyUp = !child.alreadyUp;}
          });
        }

        /////////////////////////////////
        /////////////////////////////////
        /////////////////////////////////

        // initialize event listeners
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mouseup', onTouchMove );
        window.addEventListener( 'touchend', onTouchMove );
        window.addEventListener( 'touchstart', onmesh);
        window.addEventListener( 'mousedown', onmesh);

        // variables for listner functions
        var clicked = true;
        var started = false;
        var startobj = null;
        var prevobj = null;

        /////////////////////////////////
        //  event triggered functions  //
        /////////////////////////////////

        // checks if mouse/touch start is on a mesh
        function onmesh (event)
        {
          var x, y;

          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }

          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;

          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            started = true;
            startobj = intersects[0].object;
            //clicked = !clicked;
          }
          else
          {
            started = false;
            startobj = null;
          }
        }

        // checks intersection when click up
        function onTouchMove( event )
        {
          var x, y;
          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;
          checkIntersection();
        }

        // adds object to outline list
        function addSelectedObject( object )
        {
          selectedObjects = [];
          selectedObjects.push( object );
        }

        // checks intersection and outlines/play animation accordingly
        function checkIntersection()
        {
          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            //outlinePass.selectedObjects = [];

            var selectedObject = intersects[ 0 ].object;
            console.log(selectedObject.parent);

            addSelectedObject(selectedObject);
            if (started)
            {
              if (startobj == selectedObject)
              {
                if (clicked)
                {
                  if (prevobj = selectedObject)
                  {
                    outlinePass.selectedObjects = selectedObjects;
                    openNav();
                    animateFloors(selectedObject.parent, false);
                    if(selectedObject.alreadyUp)
                    {
                      selectedObject.parent.parent.children[1].children[0].visible = true;
                      playAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
                    }
                    else
                    {
                      selectedObject.parent.parent.children[1].children[0].visible = false;
                      stopAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
                    }
                    clicked = true;
                  }
                  else
                  {
                    outlinePass.selectedObjects = [];
                    closeNav();
                    animateFloors(selectedObject.parent, true);
                    if(selectedObject.alreadyUp)
                    {
                      selectedObject.parent.parent.children[1].children[0].visible = true;
                      playAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
                    }
                    else
                    {
                      selectedObject.parent.parent.children[1].children[0].visible = false;
                      stopAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
                    }
                    clicked = false;
                  }
                }
                else
                {
                  outlinePass.selectedObjects = selectedObjects;
                  openNav();
                  animateFloors(selectedObject.parent, false);
                  if(selectedObject.alreadyUp)
                  {
                    selectedObject.parent.parent.children[1].children[0].visible = true;
                    playAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
                  }
                  else
                  {
                    selectedObject.parent.parent.children[1].children[0].visible = false;
                    stopAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
                  }
                  clicked = true;
                }
              }
            }
            else
            {
              outlinePass.selectedObjects = [];
              closeNav();
              animateFloors(selectedObject.parent, true);
              if(selectedObject.alreadyUp)
              {
                selectedObject.parent.parent.children[1].children[0].visible = true;
                playAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
              }
              else
              {
                selectedObject.parent.parent.children[1].children[0].visible = false;
                stopAnimation(selectedObject.parent.parent.children[1].children[0], 'Arrow');
              }
              clicked = false;
            }
            prevobj = selectedObject;
          }
          var width = divWidth;
          var height = divHeight;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize( width, height );
          composer.setSize( width, height );
          renderer.domElement.style.width = width + 'px';
          renderer.domElement.style.height = height + 'px';
        }

        // resize the screen correctly
        var i = 0;
        function onWindowResize()
        {
          divWidth = window.innerWidth;// / 2;
          divHeight = window.innerHeight; // 2;
          var width = divWidth;
          var height = divHeight;
          var w2 = 0;//200/7;//= xx;
          var h2 = 0;//= yy;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize( width, height );
          composer.setSize( width, height );
          renderer.domElement.style.width = width + 'px';
          renderer.domElement.style.height = height + 'px';
          //renderer.domElement.style.offsetLeft = w2 + 'px';
          //renderer.domElement.style.offsetTop = h2 + 'px';
          effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );


          var css = '#canvas {background-color: #f0f; margin-left: ' + w2.toString() + 'vw; width: 0px; height: 0px; padding: 0px; margin-top: ' + h2.toString() + 'vw; position: static;}',
          head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');

          var y;


          style.type = 'text/css';
          if (style.styleSheet)
          {
            // This is required for IE8 and below.
            style.styleSheet.cssText = css;
          }
          else
          {
            t = document.createTextNode(css);
            style.appendChild(t);

            if (style.childNodes.length <1)
            {
              //y = style.childNode[0];
              style.removeChild(style.childNode[style.childNodes.length - 1]);
              head.style.childNodes[0].kill();
              head.style.childNodes[i].kill();
              style.removeChild(style.childNode[0]);
              head.style.childNodes[i-1].kill();
              style.removeChild(style.childNode[i]);
              style.removeChild(style.childNode[i-1]);
              head.style.childNodes[style.childNodes.length - 1].kill();
              //console.log(style.childNodes.length);

              i++;
            }


            //head.style.textContent = css;
          }

          head.appendChild(style);

          if (head.childNodes.length > 1)
          {
            //y = style.childNodes[0];
            //head.removeChild(y);
          }
        }

        // variables needed before draw loop
        var panx = 1;
        var panz = 1;
        var i  = .99;
        var spor = -1;

        // draw loop
        function animate()
        {
          requestAnimationFrame( animate );
          //stats.begin();
          var timer = performance.now();

					// weak attempt at pan limiting
          if (controls.target.x > panx) {
              controls.target.x = panx;
          }
          if (controls.target.x < -1 * panx) {
              controls.target.x = -1 * panx;
          }
          if (controls.target.z > panz) {
              controls.target.z = panz;
          }
          if (controls.target.z < -1 * panz) {
              controls.target.z = -1 * panz;
          }
          controls.target.y = 0;

          var speed = .003;

          if (i >= 1)
          {
            i = 1;
            spor = -1;
          }
          i = (i + (spor * speed));
          if (i <= 0)
          {
            i = 1;
          }

          var tls;
          for (tls = 0; tls < curveCount; tls++)
          {
            var llx;
            for (llx = 0; llx < dotlength; llx++)
            {

              var scale = 0.08;

              dots[llx].scale.x = scale * 2;
              dots[llx].scale.y = scale * 1.5;
              dots[llx].scale.z = scale * 1.5;

              curveMeshArray[tls].scale.x = Math.cos(Math.PI * 4 * i);
              curveMeshArray[tls].scale.y = Math.sin(Math.PI * 2 * i);
              curveMeshArray[tls].scale.z = Math.sin(Math.PI * 6 * i);

              dots[llx].position.x = curvee.getPoint((i + (llx / dotlength)) % 1).x * linee.scale.x;
              dots[llx].position.y = curvee.getPoint((i + (llx / dotlength)) % 1).y * linee.scale.y;
              dots[llx].position.z = curvee.getPoint((i + (llx / dotlength)) % 1).z * linee.scale.z;

              dots[llx].rotation.x = -1 * curvee.getTangent((i + (llx / dotlength)) % 1).x - .25;
              dots[llx].rotation.y = 1 * curvee.getTangent((i + (llx / dotlength)) % 1).y;
              dots[llx].rotation.z = -1 * curvee.getTangent((i + (llx / dotlength)) % 1).z;
            }
          }


          controls.update();
          composer.render();
          mixer.update(clock.getDelta());

          scene.background = new THREE.Color(0xc0d9ff);
          }
        </script>
    </body>
</html>
