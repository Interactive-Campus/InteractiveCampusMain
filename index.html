<!DOCTYPE html>
<html>
    <title>Nangaku Building</title>
      <head>
      <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
        body {
            font-family: "Gill Sans", sans-serif;
        }

        .sidenav {
            height: 100%;
            width: 0;
            position: fixed;
            z-index: 1;
            top: 0;
            right: 0;
            background-color: #111;
            overflow-x: hidden;
            transition: 0.5s;
            padding-top: 60px;
        }

        .sidenav a {
            padding: 4px 10px 4px 10px;
            text-decoration: none;
            font-size: 25px;
            color: #818181;
            display: block;
            transition: 0.3s;
        }

        .dropdown-container{
          display:none;
        }

        .sidenav a:hover {
            color: #f1f1f1;
        }

        .sidenav .closebtn {
            position: absolute;
            top: 0;
            right: 10px;
            font-size: 36px;
            margin-left: 50px;
        }

        p
        {
          font-size: 18px;
          padding-left: 10px;
          padding-right: 3px;
          padding-top: 0px;
          padding-bottom: 0px;
          color: #818181;
        }

        #main {
            transition: margin-left .5s;
            padding: 16px;
        }

        @media screen and (max-height: 450px) {
          .sidenav {padding-top: 15px;}
          .sidenav a {font-size: 18px;}
        }
        </style>
      </head>
    <body>

      <div id="mySidenav" class="sidenav">
      <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

      <a class="dropdown-btn">Garrett's Amazing 10/10 English 9 Presentation
        <i class="fa fa-caret-down"></i>
      </a>

      <div class="dropdown-container">
        <p>10:10-11:15am</p>
        <p>Location: N-110</p>
        <a href="#">Directions</a>
    </div>
        <a class="dropdown-btn">Chinese Club Lunch
          <i class="fa fa-caret-down"></i>
        </a>

        <div class="dropdown-container">
          <p>12:15-1:00pm</p>
          <p>Location: N-203</p>
          <a href="#">Directions</a>
    </div>
    <a class="dropdown-btn">Keables' Scholar Discussion
      <i class="fa fa-caret-down"></i>
    </a>

    <div class="dropdown-container">
      <p>12:15-1:00pm</p>
      <p>Location: N-105</p>
      <a href="#">Directions</a>
    </div>

      <script src="js/three.js"></script>
      <script src="js/curve.js"></script>
      <script src="js/controls/OrbitControls.js"></script>
      <script src="js/loaders/GLTFLoader.js"></script>
      <script src="js/shaders/CopyShader.js"></script>
      <script src="js/shaders/FXAAShader.js"></script>
      <script src="js/postprocessing/EffectComposer.js"></script>
      <script src="js/postprocessing/RenderPass.js"></script>
      <script src="js/postprocessing/ShaderPass.js"></script>
      <script src="js/postprocessing/OutlinePass.js"></script>
      <script src="js/libs/stats.min.js"></script>
      <script src='js/libs/dat.gui.min.js'></script>
      <script src="js/loaders/OBJLoader.js"></script>
      <script src='js/NameList.js'></script>
      <div id = 'canvas'>
        <script>
        // https://stackoverflow.com/questions/13542175/three-js-ray-intersect-fails-by-adding-div/13544277#13544277

        // heap clears frequently, nodes do not

        function openNav() {
            document.getElementById("mySidenav").style.width = "250px";
        }
        function closeNav() {
            document.getElementById("mySidenav").style.width = "0";
        }

        // create dropdown within sidebar and add listener for toggle
        var dropdown = document.getElementsByClassName("dropdown-btn");
        var i;
        for (i = 0; i < dropdown.length; i++) {
          dropdown[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var dropdownContent = this.nextElementSibling;
            if (dropdownContent.style.display === "block") {
              dropdownContent.style.display = "none";
            } else {
              dropdownContent.style.display = "block";
            }
          });
        }

        // use this function to interact with JavaScript from sidebar interaction
        const changeText = () => {}

        // declaring big boy variables
        var t;
        var container, stats;
        var camera, scene, renderer, controls;
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var selectedObjects = [];
        var composer, effectFXAA, outlinePass;
        var group = new THREE.Group();
        var obj3d = new THREE.Object3D();
        var clips;
        var mixer = new THREE.AnimationMixer();
        var clock = new THREE.Clock(true);
        var divWidth = window.innerWidth;
        var divHeight = window.innerHeight;
        var objloader = new THREE.OBJLoader();

        var dots = new Array();
        var radius = .2;
        var convtxs = new Float32Array();
        var dotlength;
        var linee;

        var geometr = new THREE.BoxGeometry( radius, radius, radius);
        var materia = new THREE.MeshLambertMaterial( {color: 0xff0000} );
        var spher = new THREE.Mesh( geometr, materia );

        var nucurve;


        var ie;
        var curvee = new THREE.CatmullRomCurve3();
        var pieces = 2;

        var curveArray = new Array();
        var curveEqArray = Array();
        var curvesToAdd = Array();
        var cuvesToAni = Array();

        var matt = new THREE.LineBasicMaterial( { color : 0x00ff00, linecap: 'square', linejoin: 'square', linewidth: 5 } );

        var totaldots = 1000;

        function findRoom (stringg)
        {

        }


        function dot (u)
        {
          var geometr = new THREE.BufferGeometry();
          var ohold;
          objloader.load(
          // resource URL
          'models/arruw.obj',
          // called when resource is loaded
          function ( object ) {

            ohold = object.children[0].geometry;

            var materia = new THREE.MeshBasicMaterial( {color: 0xff0000} );
            var lxl;
            for (lxl = 0; lxl < u; lxl++)
            {
              dots[lxl] = new THREE.Mesh( ohold, materia );
              //dots[lxl].material.visible = true;
              dots[lxl].position.y = 42069360;
              scene.add(dots[lxl]);

              //console.log(lxl, dots[lxl]);
              //scene.add(dots[lxl]);
              dotlength = dots.length;
            }
            console.log(dots.length);

          } );

          console.log(dots.length, "asdf");
        }

        function indexDown (index)
        {
          if (index != 0)
          {
            return index - 1;
          }
          return 0;
        }


        function comppts (q, arr, index)
        {
          var curveptarray = new Array();
          for (ie = 0; ie < (q / 3) - 1; ie++)
          {
            if (ie % pieces == 0)
            {
              curveptarray[ie/pieces] = new THREE.Vector3(arr[ie * 3], arr[ie * 3 + 1], arr[ie * 3 + 2]);
            }
          }
          curveEqArray[index] = new THREE.CatmullRomCurve3();
          curveEqArray[index].points = curveptarray;
          //scene.add( curveEqArray[index] );
          //curveptarray = new Array();

          console.log("help", index);
          console.log("help", curveEqArray[index]);
        }

        function spSetup(file, id, roomLink, stScale, yScale, xp, yp, zp)
        {
          objloader.load(
          // resource URL
          file,
          // called when resource is loaded
          function ( object ) {
            nucurve = new THREE.Line(object, matt);
            comppts(object.children[0].geometry.attributes.position.array.length, object.children[0].geometry.attributes.position.array, id);
            var toobg = new THREE.TubeBufferGeometry( curveEqArray[id], 100, .03, 4, false );
            var toobm = new THREE.MeshBasicMaterial( { color: 0xff0000} );
            curveArray[id] = new THREE.Mesh( toobg, toobm );
            curveArray[id].scale.x = stScale;
            curveArray[id].scale.y = stScale;
            curveArray[id].scale.z = stScale;
            curveArray[id].position.x = xp;
            curveArray[id].position.y = yp;
            curveArray[id].position.z = zp;
            curveArray[id].name = roomLink;
            console.log("COOKIE", curveArray[id]);
            scene.add( curveArray[id] );
          });
        }

        function init2 ()
        {
          spSetup('models/sample_curve4.obj', 0, 'C-101', 2, 1, 2, 0, 0);
          spSetup('models/sample_curves.obj', 1, 'W-203', 2, 1, 0, 3, 0);
          spSetup('models/sample_curve2.obj', 2, 'I-212', 2, 1, 3, 2, 0);
          spSetup('models/sample_curve8.obj', 3, 'C-1xx', 2, 1, 0, 3, 1);
          spSetup('models/sample_curve3.obj', 4, 'G-101', 2, 1, 1, 1, 1);
          spSetup('models/sample_curve3.obj', 5, 'C-xxx', 2, 1, 1, 1, 1);
        }
      init();
      onWindowResize();
      animate();

      function init()
      {
        //startClosed();

        container = document.getElementById( 'canvas' );
        document.body.appendChild( container );

        renderer = new THREE.WebGLRenderer({ alpha: true });
        container.appendChild( renderer.domElement );


        // set to cutout size in the future
        var width = divWidth;
        var height = divHeight;

        // enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;

        // initialize scene
        scene = new THREE.Scene();


        // initialize and position camera
         camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
        camera.position.set( 0, 0, 0 );

        // initialize and customize controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 2;
        controls.maxDistance = 100;
        controls.maxPolarAngle = 11*Math.PI/24;
        controls.enablePan = true;
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.target.x =  1;
        controls.enableZoom = true;

        // add ambient light
        scene.add( new THREE.AmbientLight( 0xffffff, .4 ) );

        var light = new THREE.DirectionalLight(0xffffff,1);
        light.position.set(0, 500, 200);
        light.target.position.set(0, 0, 0);
        light.shadow.mapSize.width = 1024*4;
        light.shadow.mapSize.height = 1024*4;
        light.castShadow = true;

        light.shadow.camera.near = 0;
        light.shadow.camera.far = 4000;
        light.shadow.camera.fov = 90;
        scene.add(light);





        /*
        *Model Loaders
        */
        //TODO Add Import for splines from Braxton
        /*
        *Main function to load in the school model.
        *path takes a string of the file path of the model (GLTF format)
        *position takes a Vector3 and sets the the model centered to that position
        *modelGroup takes a Group and makes it the top of the tree
        *Each mesh in the model is added to a group based on the scene that it is in
        *each scene is then added to modelGroup
        *
        *The tree is divided by Building, floor, and room.
        *Each Section has splines assigned to it used for pathfinding
        *
        *                     Outline of tree system
        *
        * Main Group -> Buildings - > Floors - > Rooms
        *                   |            |         |
        *"Highway" Splines to entrance   |         |
        *         Splines From Entrance to floor   |
        *                       Splines from stairway / floor Entrance to room
        */
        var loader = new THREE.GLTFLoader();

        function loadCampus(path, position, modelGroup){
          loader.load( path, function ( gltf )
          {
            clips = gltf.animations;
            /*
            *Each Scene is named a 1 letter code for what building it represents
            *E.G. Weinberg is W, Nangaku is N
            */
            gltf.scenes.forEach(function (curScene){
              var buildingGroup = new THREE.Group();
              buildingGroup.name = curScene.name;
              var sceneLength = curScene.children.length;
              /*
              *Creates 4 floors for each Building, not all are used
              *each room is stored in its floor,
              *Each floor is assigned a name e.g  N2 and a pathfinding line
              */
              var floor1 = new THREE.Group();
              buildingGroup.add(floor1);
              floor1.name = buildingGroup.name + "1";

              var floor2 = new THREE.Group();
              buildingGroup.add(floor2);
              floor2.name = buildingGroup.name + "2";

              var floor3 = new THREE.Group();
              buildingGroup.add(floor3);
              floor3.name = buildingGroup.name + "4";

              var floor4 = new THREE.Group();
              buildingGroup.add(floor4);
              floor4.name = buildingGroup.name + "4";

              var floor5 = new THREE.Group();
              buildingGroup.add(floor5);
              floor5.name = buildingGroup.name + "5";

              /*
              *Each mesh has a prefix indicating the building it is a part of and the floor
              *e.g. N2 means Nangaku second floor
              *Each room is named after its room number e.g. N203 or N204
              *Each non room mesh is named with its prefix and followed by part
              */
              for(var i = 0; i < sceneLength; i++){
                switch (curScene.children[0].name.slice(1,2)) {
                  case "1":
                    floor1.add(curScene.children[0]);
                    break;

                  case "2":
                    floor2.add(curScene.children[0]);
                    break;

                  case "3":
                    floor3.add(curScene.children[0]);
                    break;

                  case "4":
                    floor4.add(curScene.children[0]);
                    break;

                  case "5":
                    floor5.add(curScene.children[0]);
                    break;

                  default:
                    floor1.add(curScene.children[0]);
                }
              }
              buildingGroup.children.forEach( function (child){
                child.children.forEach(function(room){
                  if (room instanceof THREE.Mesh){
                    room.receiveShadow = true;
                    room.castShadow = true;
                    room.material.side = THREE.DoubleSide;
                    room.geometry.computeBoundingSphere();

                    //tests if the mesh is a room or just an aesthetic part
                    if(room.name.slice(2, -3) == 'part'){
                      //Adds custom object containing if it is a selectable room and if it is already animated and the name(s) of the room
                      room.userData = {alreadyUp:false, isRoom:false, isRestroom:false};
                    }
                    //tests if mesh is stairs, stairs must use special animation
                    else if (room.name.slice(2, -3) == 'Restroom'){
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:true};
                    }
                    else{
                      //Accesses a list of names and adds each one to the model
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:false, names:findNames(child.name)};
                    }
                    if(room.userData.isRestroom){
                      createRestroom(room.position);
                      console.log(room)
                    }
                  }

                 else if (room instanceof THREE.Group){
                    room.children.forEach(function(children){
                      children.receiveShadow = true;
                      children.castShadow = true;
                      children.geometry.computeBoundingSphere();
                      children.material.side = THREE.DoubleSide;
                    });

                    //tests if the mesh is a room or just an aesthetic part
                    if(room.name.slice(2, -3) == 'part'){
                      //Adds custom object containing if it is a selectable room and if it is already animated and the name(s) of the room
                      room.userData = {alreadyUp:false, isRoom:false, isRestroom:false};
                    }
                    //tests if mesh is stairs, stairs must use special animation
                    else if (room.name.slice(2, -3) == 'Restroom'){
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:true};
                    }
                    else{
                      //Accesses a list of names and adds each one to the model
                      room.userData = {alreadyUp:false, isRoom:true, isRestroom:false, names:findNames(child.name)};
                    }
                    if(room.userData.isRestroom){
                      createRestroom(room.position);
                      console.log(room.children[0].geometry.boundingSphere.center );
                    }
                  }

                });
              });
              modelGroup.add(buildingGroup);
            });
          });
          modelGroup.position.copy(position);
        }

        // add Nangaku model
        loadCampus('models/CampusMapFinalV2.gltf', new THREE.Vector3(1,0,50), group);

        controls.target = new THREE.Vector3(1,0,50);

        //add the group of all models into the scene
        scene.add( group );



        //init2();
        dot(totaldots);

        // add and position floor
        var floorMaterial = new THREE.MeshPhongMaterial({color: 0x6d6d6d});
        var floorGeometry = new THREE.PlaneBufferGeometry(100, 100);
        var floorMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
        var floorGeometry = new THREE.PlaneBufferGeometry(20, 20);
        var floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x -= Math.PI * 0.5;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        floorMesh.castShadow = true;
        //scene.add(floorMesh);

        // initialize postprocessing
        composer = new THREE.EffectComposer( renderer );
        var renderPass = new THREE.RenderPass( scene, camera );
        composer.addPass( renderPass );
        outlinePass = new THREE.OutlinePass( new THREE.Vector2( divWidth, divHeight ), scene, camera );
        composer.addPass( outlinePass );

        // initialize antialiasing
        effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );



        var restroomSignMap = new THREE.TextureLoader().load( "Sprites/RestroomSign.png" );
        var restroomSignMaterial = new THREE.SpriteMaterial( { map: restroomSignMap, color: 0xffffff } );

        function createRestroom(position){
          var restroomSign = new THREE.Sprite( restroomSignMaterial );
          restroomSign.scale = new THREE.Vector3(10,10,10);
          restroomSign.position.copy(position);
          restroomSign.position.y = restroomSign.position.y + 1;

          group.add( restroomSign );
        }

        /*
        * Animation Functions
        */

        //given a name and am object plays an animation
        function playAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.play();
        }

        function stopAnimation(rootObject, clipName){
          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );
          action.stop();
        }

        //plays animation on a object forwards or backwards stopping on last frame
        function playFloorAnimation( rootObject, isUp, clipName ){

          var action = mixer.clipAction( THREE.AnimationClip.findByName(clips, clipName), rootObject );

          action.clampWhenFinished = true;
          action.setLoop(THREE.LoopOnce);

          if(isUp){
            action.timeScale = -1;
          }

          else{action.timeScale = 1;}
          rootObject.alreadyUp = !rootObject.alreadyUp;
          action.play();
          action.paused = false;
        }

        /*
        *Animates all floors in the building Group
        *putting 'pingPong' for animation mode toggles the animation Up and down
        * 'lower' only lowers the floors if they are up
        *'raise' raises the floors if they are dowb.
        */

        function animateFloors(selectedRoom, animationMode){
          if(animationMode  == 'PingPong'){
            selectedRoom.parent.parent.children.forEach(function(child){
              child.children.forEach(function(room){
                //plays animations by the name of the floors, each floor's suffix has a matching animation
                if (THREE.AnimationClip.findByName(clips,room.name.slice(0, -3)) != null){
                  playFloorAnimation(room, room.alreadyUp, room.name.slice(0, -3));
                }
                else{room.alreadyUp = !room.alreadyUp;}
              });
            });
          }

          else if(animationMode == 'Lower'){
            selectedRoom.parent.parent.children.forEach(function(child){
              child.children.forEach(function(room){
                //plays animations by the name of the floors, each floor's suffix has a matching animation
                if (THREE.AnimationClip.findByName(clips,room.name.slice(0, -3)) != null){
                  playFloorAnimation(room, true, room.name.slice(0, -3));
                }

                else{room.alreadyUp = false;}
              });
            });
          }

          else if (animationMode == 'Raise') {
            selectedRoom.parent.parent.children.forEach(function(child){
              child.children.forEach(function(room){
                //plays animations by the name of the floors, each floor's suffix has a matching animation
                if (THREE.AnimationClip.findByName(clips,room.name.slice(0, -3)) != null){
                  playFloorAnimation(room, false, room.name.slice(0, -3));
                }
                else{room.alreadyUp = true;}
              });
            });
          }
          else {console.log("Invalid Input, use pingPong, raise, or lower")}
        }

        // initialize event listeners
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mouseup', onTouchMove );
        window.addEventListener( 'touchend', onTouchMove );
        window.addEventListener( 'touchstart', onmesh);
        window.addEventListener( 'mousedown', onmesh);
        //window.addEventListener( 'mousemove', stopstart);

        // variables for listener functions
        var clicked = true;
        var started = false;
        var lfclick = true;
        var prevobj = null;

        /////////////////////////////////
        //  event triggered functions  //
        /////////////////////////////////
        function onmesh (event)
        {
          var x, y;

          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;

          raycaster.setFromCamera( mouse, camera );
          var intersects = raycaster.intersectObjects( [ group ], true );
          if ( intersects.length > 0 )
          {
            started = true;
          }
          else
          {
            started = false;
          }

          // put opennav where

        }

        // checks intersection when click up
        function onTouchMove( event )
        {
          var x, y;
          if ( event.changedTouches )
          {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
          }
          else
          {
            x = event.clientX;
            y = event.clientY;
          }
          mouse.x = ( ( x - renderer.domElement.offsetLeft ) / renderer.domElement.clientWidth ) * 2 - 1;
          mouse.y = - ( ( y - renderer.domElement.offsetTop ) / renderer.domElement.clientHeight ) * 2 + 1;
          checkIntersection();
        }

        // adds object to outline list
        function addSelectedObject( object )
        {
          selectedObjects = [];
          selectedObjects.push( object );
        }

        function checkIntersection()
         {
           raycaster.setFromCamera( mouse, camera );
           var intersects = raycaster.intersectObjects( [ group ], true );
           if ( intersects.length > 0 )
           {
             outlinePass.selectedObjects = [];
             var selectedObject = intersects[ 0 ].object;


             if(selectedObject.name.slice(0,1) == 'M'){
               console.log(selectedObject.parent.userData.isRestroom);
             }
             else console.log(selectedObject.userData.isRestroom);

             if(selectedObject.name.slice(0,1) == 'M'){
               console.log(selectedObject.parent.name.slice(2,-3));
             }
             else console.log(selectedObject.name.slice(2, -3));

             animateFloors(selectedObject, 'PingPong');
             addSelectedObject( selectedObject );
             if (clicked && started || prevobj != selectedObject)
             {
               outlinePass.selectedObjects = selectedObjects;
               openNav();
             }
             else
             {
               outlinePass.selectedObjects = [];
               closeNav();
             }
             clicked = !clicked;
           }
           else
           {
             if (!started)
             {
               outlinePass.selectedObjects = [];
             }
           }
           prevobj = selectedObject;
         }


        var width = divWidth;
        var height = divHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize( width, height );
        composer.setSize( width, height );
        renderer.domElement.style.width = width + 'px';
        renderer.domElement.style.height = height + 'px';
      }



        // resize the screen correctly
        var i = 0;
        function onWindowResize()
        {
          divWidth = window.innerWidth;// / 2;
          divHeight = window.innerHeight; // 2;
          var width = divWidth;
          var height = divHeight;
          var w2 = 0;//200/7;//= xx;
          var h2 = 0;//= yy;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize( width, height );
          composer.setSize( width, height );
          renderer.domElement.style.width = width + 'px';
          renderer.domElement.style.height = height + 'px';
          //renderer.domElement.style.offsetLeft = w2 + 'px';
          //renderer.domElement.style.offsetTop = h2 + 'px';
          effectFXAA.uniforms[ 'resolution' ].value.set( 1 / divWidth, 1 / divHeight );


          var css = '#canvas {background-color: #f0f; margin-left: ' + w2.toString() + 'vw; width: 0px; height: 0px; padding: 0px; margin-top: ' + h2.toString() + 'vw; position: static;}',
          head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');

          var y;


          style.type = 'text/css';
          if (style.styleSheet)
          {
            // This is required for IE8 and below.
            style.styleSheet.cssText = css;
          }
          else
          {
            t = document.createTextNode(css);
            style.appendChild(t);

            if (style.childNodes.length <1)
            {
              //y = style.childNode[0];
              style.removeChild(style.childNode[style.childNodes.length - 1]);
              head.style.childNodes[0].kill();
              head.style.childNodes[i].kill();
              style.removeChild(style.childNode[0]);
              head.style.childNodes[i-1].kill();
              style.removeChild(style.childNode[i]);
              style.removeChild(style.childNode[i-1]);
              head.style.childNodes[style.childNodes.length - 1].kill();
              //console.log(style.childNodes.length);

              i++;
            }


            //head.style.textContent = css;
          }

          head.appendChild(style);

          if (head.childNodes.length > 1)
          {
            //y = style.childNodes[0];
            //head.removeChild(y);
          }
        }

        // variables needed before draw loop

        var i  = .99;
        var spor = -1;
        var ppanx;
        var ppanz;
        var pcamrot;// = camera.rotation;

        // draw loop
        function animate()
        {
          requestAnimationFrame( animate );
          //stats.begin();
          var timer = performance.now();

					// weak attempt at pan limiting
          var panx = 1;
          var panz = 1;
          if (pcamrot != camera.rotation)
          {

          }
          if (ppanx != controls.target.x || ppanz != controls.target.z)
          {
            //controls.enableRotate = false;
            //console.log(camera.rotation, pcamrot);
            camera.position = pcamrot;

          }
          else
          {
            //controls.enableRotate = true;
            pcamrot = camera.rotation;
          }

          //Camera Pan Limiter
          /*
          if (controls.target.x > panx) {
              controls.target.x = panx;
          }
          if (controls.target.x < -1 * panx) {
              controls.target.x = -1 * panx;
          }
          if (controls.target.z > panz) {
              controls.target.z = panz;
          }
          if (controls.target.z < -1 * panz) {
              controls.target.z = -1 * panz;
          }
          controls.target.y = 0;
          controls.enableDamping = false;
          ppanx = controls.target.x;
          ppanz = controls.target.z;
          //console.log(camera.rotation, pcamrot);
          //console.log(camera);
          */

          var useddots = Array();

          var speed = .0008;
          var scale = .18;
          var pointsFactor = .25;
          var room = "C-101"; // changes with clicks

          curvesToAdd = [];

          // curve adder function(s)
          var curveIndex;
          for (curveIndex = 0; curveIndex < curveArray.length; curveIndex++)
          {
            var curveChar;
            for (curveChar = 0; curveChar < curveArray[curveIndex].name.length; curveChar++)
            {
              if (room[curveChar] != curveArray[curveIndex].name[curveChar] && curveChar != 1 && curveArray[curveIndex].name[curveChar] != 'x')
              {
                break;
              }
              if (curveArray[curveIndex].name[curveChar] == 'x' || curveChar == (curveArray[curveIndex].name.length - 1))
              {
                // append CurvesToAdd
                curvesToAdd.push(curveIndex);
                break;
              }
            }
          }

          // zero to one variable
          if (i >= 1)
          {
            i = 1;
            spor = -1;
          }
          i = (i + (spor * speed));
          if (i <= 0)
          {
            i = 1;
          }

          // make curves invisible
          var blanker;
          for (blanker = 0; blanker < curveArray.length; blanker++)
          {
            curveArray[blanker].visible = false;
          }

          // calculate total needed dots
          var totaluseddots = 0;
          var eye;
          for (eye = 0; eye < curvesToAdd.length; eye++)
          {
            totaluseddots += curveEqArray[curvesToAdd[eye]].points.length * pointsFactor;
            useddots[eye] = curveEqArray[curvesToAdd[eye]].points.length * pointsFactor;
          }

          // make selected curves visible, position and move them along curve
          var dotally = 0;
          var p;
          for (p = 0; p < curvesToAdd.length; p++)
          {
            curveArray[curvesToAdd[p]].visible = true;
            for (q = 0; q < useddots[p]; q++)
            {
              dots[dotally].scale.x = scale * 1.5;
              dots[dotally].scale.y = scale * 1.5;
              dots[dotally].scale.z = scale * 1.5;

              dots[dotally].position.x = curveEqArray[curvesToAdd[p]].getPoint((i + (q / useddots[p])) % 1).x * curveArray[curvesToAdd[p]].scale.x + curveArray[curvesToAdd[p]].position.x;
              dots[dotally].position.y = curveEqArray[curvesToAdd[p]].getPoint((i + (q / useddots[p])) % 1).y * curveArray[curvesToAdd[p]].scale.y + curveArray[curvesToAdd[p]].position.y;
              dots[dotally].position.z = curveEqArray[curvesToAdd[p]].getPoint((i + (q / useddots[p])) % 1).z * curveArray[curvesToAdd[p]].scale.z + curveArray[curvesToAdd[p]].position.z;

              dotally++;
            }
          }

          // THREE functions updatae
          controls.update();
          composer.render();
          mixer.update(clock.getDelta());

          scene.background = new THREE.Color(0xc0d9ff);
          }
        </script>
    </body>
</html>
